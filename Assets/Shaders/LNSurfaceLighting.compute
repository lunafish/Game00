#pragma kernel CSMain
#pragma kernel CS_SSAO
#pragma kernel CS_SSAO_Blur
#pragma kernel CS_SSR
#pragma kernel CS_SSR_Blur
#pragma kernel CS_SSGI
#pragma kernel CS_SSGI_Blur
#pragma kernel CS_SSCS

// 최종 결과를 저장할 렌더 타겟
RWTexture2D<float4> _Result;
RWTexture2D<float> _Result_AO; // SSAO 용

// --- 입력 텍스처 (GBuffer 자료형) ---
Texture2D<float4> _LNSurface_Front_Color;  // RGB: 알베도(Albedo), A: 미사용
Texture2D<float4> _LNSurface_Front_Packed; // RG: Oct-Encoded Normal, B: Linear Depth, A: 미사용
Texture2D<float4> _LNSurface_Front_Extra;  // R: Mask, G: Metallic, B: Smoothness, A: Unused
Texture2D<float4> _LNSurface_Front_Extra2; // R: Shadow, G: Packed(Sub/Aniso), B: Packed(Int/Thick), A: Unused

Texture2D<float4> _LNSurface_Back_Color;   // RGB: 뒷면 컬러
Texture2D<float4> _LNSurface_Back_Packed;  // RG: Oct-Encoded Normal, B: Linear Depth, A: 미사용

Texture2D<float4> _SceneColor;             // 배경 씬 컬러 (SSR 반사 소스)

Texture2D<float> _AO_Raw;                // 블러 전 SSAO 소스
Texture2D<float> _LNSurface_AO_Blurred; // 블러 후 최종 SSAO

RWTexture2D<float4> _Result_SSR; // SSR 용 (HDR)
Texture2D<float4> _SSR_Raw;               // 블러 전 SSR 소스
Texture2D<float4> _LNSurface_SSR_Blurred; // 블러 후 최종 SSR

RWTexture2D<float4> _Result_SSGI; // SSGI 용 (HDR)
Texture2D<float4> _SSGI_Raw;               // 블러 전 SSGI 소스
Texture2D<float4> _LNSurface_SSGI_Blurred; // 블러 후 최종 SSGI

RWTexture2D<float> _Result_SSCS; // SSCS 용 (R8) - 쓰기 전용
Texture2D<float> _SSCS_Texture;  // SSCS 용 (R8) - 읽기 전용

SamplerState painter_linear_clamp_sampler;

// --- 전역 파라미터 ---
float2 _LNSurface_ScreenParams;     // 화면 해상도 (이름 변경)
float4 _MainLightDirection; // 메인 라이트 방향
float4 _MainLightColor;     // 메인 라이트 색상 및 강도
int _AdditionalLightCount;  // 추가 라이트 개수 (최대 16)
float4 _AdditionalLightPositions[16];
float4 _AdditionalLightColors[16];
float4 _AdditionalLightAttenuations[16]; // x: 거리 감쇠 역제곱, y: 미사용

// 하부표면 산란(SSS) 설정
float _SSS_Intensity;     // SSS 강도
float _SSS_ThicknessScale; // 두께 계수
float _EnableSSS;          // SSS 활성화 여부

// 구면 조화 함수(SH) - Ambient Light 연산용
float4 unity_SHAr, unity_SHAg, unity_SHAb;
float4 unity_SHBr, unity_SHBg, unity_SHBb;
float4 unity_SHC;

// 행렬 데이터
float4x4 _InverseProjectionMatrix; // 뷰 공간 재구성을 위한 투영 역행렬
float4x4 _CameraToWorldMatrix;      // 뷰 -> 월드 변환
float4x4 _WorldToCameraMatrix;      // 월드 -> 뷰 변환
float4x4 _ProjectionMatrix;         // 월드 -> 클립 변환
int _LightingModel; // 조명 모델 선택 (0: HalfLambert, 1: DisneyBRDF)

// Material Global Settings
float _SpecularStrength;
float _DiffuseWrap;

// Shadow Tint Settings
int _ShadowTintMode; // 0: Custom, 1: Complementary
float4 _ShadowTintColor;
float _ShadowTintIntensity;
float _ShadowThreshold; // 0.0 ~ 1.0

// 화면 공간 반사(SSR) 설정
float _EnableSSR;      // SSR 활성화 여부
int _SSR_MaxSteps;     // 최대 레이마칭 단계
float _SSR_StepSize;    // 레이 전진 보폭
float _SSR_Thickness;   // 충돌 판정 두께 임계값

// --- SSAO (Screen Space Ambient Occlusion) 설정 ---
float _EnableSSAO;      // SSAO 활성화 여부
float _SSAO_Radius;     // 차폐 탐색 반경
float _SSAO_Intensity;  // 차폐 강도
int _SSAO_SampleCount;  // 샘플 개수 (4~32 권장)

// --- SSGI (Screen Space Global Illumination) 설정 ---
float _EnableSSGI;
float _SSGI_Intensity;
int _SSGI_SampleCount;
float _SSGI_RayStepSize;

// --- SSCS (Screen Space Cast Shadow) 설정 ---
float _EnableSSCS;
float _SSCS_Distance;
int _SSCS_MaxSteps;
float _SSCS_Thickness;
float _SSCS_Intensity; // SSCS 강도 추가

#ifndef PI
#define PI 3.14159265359f
#endif

// --- Helper Functions ---

float2 OctWrap(float2 v)
{
    return (1.0 - abs(v.yx)) * (v.xy >= 0.0 ? 1.0 : -1.0);
}

float3 DecodeNormal(float2 f)
{
    f = f * 2.0 - 1.0;
    float3 n = float3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
    float t = saturate(-n.z);
    n.xy += n.xy >= 0.0 ? -t : t;
    return normalize(n);
}

// --- Color Utility Functions (HSV) ---
float3 RGBtoHSV(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 HSVtoRGB(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float3 GetShadowColor(float3 lightColor)
{
    if (_ShadowTintMode == 0) // Custom
    {
        return _ShadowTintColor.rgb;
    }
    else // Complementary (HSV Hue Shift)
    {
        float3 hsv = RGBtoHSV(lightColor);
        hsv.x = frac(hsv.x + 0.5); // 180도 회전
        
        float saturationFactor = 0.7;
        // 보색의 채도를 주광원 채도의 70%로 낮춤 (최소값 0.1 보장)
        hsv.y = max(hsv.y * saturationFactor, 0.1); 
        
        // 명도(Value)도 채도가 빠지는 만큼 어둡게 (70% 수준)
        hsv.z *= saturationFactor;
        
        return HSVtoRGB(hsv);
    }
}

// --- Disney BRDF 유틸리티 함수 ---
float Local_Sqr(float x) { return x * x; }

// Schlick Fresnel 근사식
float Local_SchlickFresnel(float u)
{
    float m = clamp(1.0 - u, 0.0, 1.0);
    float m2 = m * m;
    return m2 * m2 * m; // pow(m, 5)
}

// GTR2 분포 함수 (GGX 코어)
float Local_GTR2(float NdotH, float a)
{
    float a2 = a * a;
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

// Smith 기하 차폐 함수 (Smith Geometric Shadowing)
float Local_G_Smith(float NdotV, float NdotL, float alpha)
{
    float a = Local_Sqr(alpha);
    float k = Local_Sqr(alpha + 1.0) * 0.125; // 직접 조명 모드
    float g1 = NdotV / (NdotV * (1.0 - k) + k);
    float g2 = NdotL / (NdotL * (1.0 - k) + k);
    return g1 * g2;
}

// 점광원 거리 감쇠 계산
float GetDistanceAttenuation(float3 lightDir, float4 attenuation)
{
    float d2 = dot(lightDir, lightDir);
    float rangeCheck = saturate(1.0 - d2 * attenuation.x);
    return rangeCheck * rangeCheck / (d2 + 0.01);
}

// Unity의 ShadeSH9과 동일한 방식으로 Ambient(주변광) 계산
float3 SampleSH(float3 normal)
{
    float4 n = float4(normal, 1.0);
    float3 x1, x2, x3;
    
    x1.r = dot(unity_SHAr, n);
    x1.g = dot(unity_SHAg, n);
    x1.b = dot(unity_SHAb, n);
    
    float4 vB = n.xyzz * n.yzzx;
    x2.r = dot(unity_SHBr, vB);
    x2.g = dot(unity_SHBg, vB);
    x2.b = dot(unity_SHBb, vB);
    
    float vC = n.x * n.x - n.y * n.y;
    x3 = unity_SHC.rgb * vC;
    
    return max(0, x1 + x2 + x3);
}

// --- SSR 헬퍼 함수 ---

// 선형 깊이와 UV를 사용하여 뷰 공간(View Space) 좌표 복구
float3 GetViewSpacePos(float2 uv, float linearDepth)
{
    float fovScaleX = _InverseProjectionMatrix._m00;
    float fovScaleY = _InverseProjectionMatrix._m11;
    
    float4 clipPos;
    clipPos.xy = uv * 2.0 - 1.0;
    clipPos.z = 0; 
    clipPos.w = 1;

    float3 viewPos;
    viewPos.z = -linearDepth; 
    viewPos.x = clipPos.x * fovScaleX * -viewPos.z; 
    viewPos.y = clipPos.y * fovScaleY * -viewPos.z;
    return viewPos;
}

// 뷰 공간 좌표를 다시 화면 UV 좌표로 투영
float3 ProjectViewPos(float3 viewPos)
{
    float4 clipPos = mul(_ProjectionMatrix, float4(viewPos, 1.0));
    float3 ndcPos = clipPos.xyz / clipPos.w;
    return float3(ndcPos.xy * 0.5 + 0.5, ndcPos.z);
}

// --- SSAO/SSGI 헬퍼 함수 ---

// 해시 기반 의사 난수 생성기 (샘플링 위치 지터링용)
float Local_Hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return (float)seed / 4294967296.0;
}

void GetOrthonormalBasis(float3 n, out float3 tangent, out float3 bitangent)
{
    float3 up = abs(n.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
    tangent = normalize(cross(up, n));
    bitangent = cross(n, tangent);
}

float3 GetCosineHemisphereDir(float3 n, uint seed)
{
    float2 rand = float2(Local_Hash(seed), Local_Hash(seed + 114));
    float r = sqrt(rand.x);
    float phi = 2.0 * PI * rand.y;
    
    float3 localDir = float3(r * cos(phi), r * sin(phi), sqrt(max(0.0, 1.0 - rand.x)));
    
    float3 t, b;
    GetOrthonormalBasis(n, t, b);
    
    return t * localDir.x + b * localDir.y + n * localDir.z;
}

/**
 * 볼륨 기반 SSAO 연산 (Back Depth 활용)
 * @param posWS: 현재 픽셀의 월드 공간 위치
 * @param normalWS: 현재 픽셀의 월드 공간 노멀
 * @param pixId: 현재 스레드 ID (픽셀 좌표)
 */
float CalculateSSAO(float3 posWS, float3 normalWS, uint2 pixId)
{
    if (_EnableSSAO < 0.5) return 0.0;

    // 뷰 공간 데이터로 변환
    float3 viewNormal = mul((float3x3)_WorldToCameraMatrix, normalWS);
    float3 viewPos = mul(_WorldToCameraMatrix, float4(posWS, 1.0)).xyz;
    
    float occlusion = 0;
    int samples = _SSAO_SampleCount;
    
    for (int i = 0; i < samples; i++)
    {
        // 픽셀 좌표와 인덱스를 조합한 시드 생성
        uint seedInput = pixId.y * uint(_LNSurface_ScreenParams.x) + pixId.x + uint(i);
        float3 randVec = float3(
            Local_Hash(seedInput),
            Local_Hash(seedInput + 100),
            Local_Hash(seedInput + 200)
        ) * 2.0 - 1.0;
        
        randVec = normalize(randVec);
        
        // 반구(Hemisphere) 방향으로 정렬
        if (dot(randVec, viewNormal) < 0) randVec = -randVec;
        
        // 탐색 반경 내 무작위 지점 선정
        float weight = (float)i / (float)samples;
        float3 samplePosVS = viewPos + randVec * _SSAO_Radius * (0.1 + 0.9 * Local_Hash(seedInput + 300));
        
        // 화면 공간 투영 및 깊이 비교
        float3 sampleScreenPos = ProjectViewPos(samplePosVS);
        
        if (sampleScreenPos.x >= 0 && sampleScreenPos.x <= 1 && sampleScreenPos.y >= 0 && sampleScreenPos.y <= 1)
        {
            // Half-Res 최적화: UV 샘플링 사용
            float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleScreenPos.xy, 0).b;
            float bDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, sampleScreenPos.xy, 0).b;
            float sampleDepth = -samplePosVS.z;
            
            // 볼륨 기반 체크: 샘플이 실제 물체 내부(Front ~ Back)에 있는가?
            // 뒷면 데이터가 없을 경우(bDepth <= fDepth)를 대비해 fDepth 이후 일정 거리를 물체로 간주
            float effectiveBackDepth = (bDepth > fDepth + 0.001) ? bDepth : (fDepth + 0.1); 
            
            if (sampleDepth >= fDepth + 0.01 && sampleDepth <= effectiveBackDepth + 0.05)
            {
                // 인접성 기반 가중치 (너무 멀리 있는 벽은 무시)
                // -viewPos.z (현재 깊이)와 fDepth (샘플 지점의 실제 깊이) 비교
                float rangeCheck = smoothstep(1.0, 0.0, abs(-viewPos.z - fDepth) / _SSAO_Radius);
                occlusion += rangeCheck;
            }
        }
    }
    
    // 가중치 평균 리턴 (0: 차폐 없음, 1: 최대 차폐)
    return saturate(occlusion / (float)samples);
}


/**
 * 정밀 SSR 레이마칭 엔진
 * @param startPosVS: 시작 위치 (뷰 공간)
 * @param rayDirVS: 반사 레이 방향 (뷰 공간)
 * @param stepSize: 레이 전진 보폭
 * @param hitUV: 충돌 시 화면 UV 결과값
 * @param hitBack: 뒷면(Back face) 충돌 여부
 */
bool Raymarch(float3 startPosVS, float3 rayDirVS, float stepSize, out float2 hitUV, out bool hitBack)
{
    float3 currentPosVS = startPosVS;
    hitBack = false;
    
    for (int i = 0; i < _SSR_MaxSteps; i++)
    {
        currentPosVS += rayDirVS * stepSize;
        
        float3 screenPos = ProjectViewPos(currentPosVS);
        if (screenPos.x < 0 || screenPos.x > 1 || screenPos.y < 0 || screenPos.y > 1)
            return false;
            
        // Half-Res 최적화: UV 샘플링 사용 (Full-Res GBuffer 읽기)
        float frontDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        float backDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        
        float currentDepth = -currentPosVS.z;
        
        // Back Depth 유효성 체크 (1000.0은 Clear Value)
        bool hasBackFace = (backDepth < 900.0);

        // 유효한 뒷면이 있으면 볼륨 판정, 없으면 단순 두께 판정
        float thicknessThreshold = hasBackFace ? (backDepth - frontDepth) : _SSR_Thickness;
        // 뒷면이 앞면보다 앞에 있는 경우(오류) 보정
        thicknessThreshold = max(thicknessThreshold, _SSR_Thickness); 
        
        // 레이가 물체의 두께(앞면과 뒷면 사이 볼륨) 안에 진입했는지 확인
        if (currentDepth >= frontDepth && currentDepth <= frontDepth + thicknessThreshold)
        {
            // 교점 정밀화를 위한 이진 탐색 (Binary Search Refinement)
            float3 prevPosVS = currentPosVS - rayDirVS * stepSize;
            for (int j = 0; j < 4; j++)
            {
                float3 midPosVS = (prevPosVS + currentPosVS) * 0.5;
                float3 midScreenPos = ProjectViewPos(midPosVS);
                
                float midFront = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, midScreenPos.xy, 0).b;
                float midDepth = -midPosVS.z;
                
                // 이진 탐색 중에는 단순 두께 판정 사용 (성능 고려)
                if (midDepth >= midFront && midDepth <= midFront + _SSR_Thickness)
                    currentPosVS = midPosVS;
                else
                    prevPosVS = midPosVS;
            }
            
            float3 finalScreenPos = ProjectViewPos(currentPosVS);
            
            float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, finalScreenPos.xy, 0).b;
            float bDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, finalScreenPos.xy, 0).b;
            float cDepth = -currentPosVS.z;

            hitUV = finalScreenPos.xy;
            // 앞면 보다는 뒷면에 더 가까운지, 그리고 실제 뒷면 깊이 데이터가 유효한지 판단
            hitBack = (abs(cDepth - bDepth) < abs(cDepth - fDepth)) && (bDepth > fDepth);
            return true;
        }
    }
    return false;
}

// --- SSCS Raymarching ---
float RaymarchShadow(float3 startPosVS, float3 lightDirVS, float maxDist, uint2 pixId)
{
    float3 currentPosVS = startPosVS;
    float stepSize = maxDist / (float)_SSCS_MaxSteps;
    float shadow = 1.0;
    
    // Jittering: 픽셀마다 시작 위치를 랜덤하게 이동하여 Banding 완화
    float dither = Local_Hash(pixId.y * uint(_LNSurface_ScreenParams.x) + pixId.x);
    currentPosVS += lightDirVS * stepSize * dither;
    
    // Bias: Self-Shadowing 방지용 Depth Bias (0.02 -> 0.005로 감소)
    float bias = 0.005; 

    for (int i = 0; i < _SSCS_MaxSteps; i++)
    {
        currentPosVS += lightDirVS * stepSize;
        
        float3 screenPos = ProjectViewPos(currentPosVS);
        if (screenPos.x < 0 || screenPos.x > 1 || screenPos.y < 0 || screenPos.y > 1)
            break; // 화면 밖으로 나가면 그림자 없음 (빛)
            
        float frontDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        float backDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        float currentDepth = -currentPosVS.z;
        
        // Back Depth 유효성 체크
        bool hasBackFace = (backDepth < 900.0);
        float thickness = hasBackFace ? (backDepth - frontDepth) : _SSCS_Thickness;
        thickness = max(thickness, _SSCS_Thickness);

        // 레이가 물체 뒤로 들어갔는지 확인 (Occlusion)
        // Bias를 적용하여 자기 자신의 표면 바로 뒤는 무시
        if (currentDepth > frontDepth + bias && currentDepth < frontDepth + thickness)
        {
            shadow = 0.0; // 가려짐
            break;
        }
    }
    
    // 강도 적용 (0: 완전 그림자, 1: 그림자 없음) -> lerp(1, shadow, intensity)
    return lerp(1.0, shadow, _SSCS_Intensity);
}

// ------------------------------------------------
// SSAO 전용 계산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSAO (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    // Half-Res UV 계산
    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;

    // Full-Res GBuffer 샘플링
    float mask = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
    if (mask <= 0.001)
    {
        _Result_AO[id.xy] = 0.0; // No occlusion
        return;
    }

    // GBuffer에서 월드 공간 정보 복원
    float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 viewPos = GetViewSpacePos(uv, fDepth);
    float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
    float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);

    _Result_AO[id.xy] = CalculateSSAO(worldPos, normalWS, id.xy);
}

// ------------------------------------------------
// SSAO Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSAO_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float totalAO = 0;
    float totalWeight = 0;

    // SSAO는 고정 반경 (예: 2) 사용, Gaussian Weight 적용
    int radius = (int)lerp(1.0, 8.0, _SSAO_Radius);
    float sigma = max(0.1, radius / 2.0);

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(
                clamp(id.x + x, 0, (uint)_LNSurface_ScreenParams.x - 1),
                clamp(id.y + y, 0, (uint)_LNSurface_ScreenParams.y - 1)
            );
            
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float sampleAO = _AO_Raw[sampleId].r;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            // Gaussian Spatial Weight
            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            
            // Binary Depth Weight: 깊이 차이가 0.01 미만이면 1, 아니면 0
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.01) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;
            
            totalAO += sampleAO * weight;
            totalWeight += weight;
        }
    }

    _Result_AO[id.xy] = totalAO / max(0.0001, totalWeight);
}

// ------------------------------------------------
// SSGI 전용 계산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSGI (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;

    float mask = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
    if (mask <= 0.001)
    {
        _Result_SSGI[id.xy] = 0.0;
        return;
    }

    float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 viewPos = GetViewSpacePos(uv, fDepth);
    
    float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);
    float3 normalVS = mul((float3x3)_WorldToCameraMatrix, normalWS);
    
    float3 indirectLight = 0;
    int samples = _SSGI_SampleCount;
    
    for(int i=0; i<samples; i++)
    {
        uint seed = id.y * uint(_LNSurface_ScreenParams.x) + id.x + uint(i * 152);
        float3 rayDirVS = GetCosineHemisphereDir(normalVS, seed);
        
        float2 hitUV;
        bool hitBack;
        
        if(Raymarch(viewPos, rayDirVS, _SSGI_RayStepSize, hitUV, hitBack))
        {
            float3 hitColor = _SceneColor.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
            indirectLight += hitColor;
        }
    }
    
    _Result_SSGI[id.xy] = float4(indirectLight / max(1, samples), 1.0);
}

// ------------------------------------------------
// SSGI Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSGI_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 totalColor = 0;
    float totalWeight = 0;

    int radius = 4;
    float sigma = 2.0;

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(
                clamp(id.x + x, 0, (uint)_LNSurface_ScreenParams.x - 1),
                clamp(id.y + y, 0, (uint)_LNSurface_ScreenParams.y - 1)
            );
            
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float3 sampleColor = _SSGI_Raw[sampleId].rgb;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.05) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;
            
            totalColor += sampleColor * weight;
            totalWeight += weight;
        }
    }

    _Result_SSGI[id.xy] = float4(totalColor / max(0.0001, totalWeight), 1.0);
}

// ------------------------------------------------
// SSCS 전용 계산 커널 (Full-Res 권장, 여기선 Half-Res로 구현)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSCS (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float mask = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
    
    if (mask <= 0.001)
    {
        _Result_SSCS[id.xy] = 1.0; // No shadow
        return;
    }

    float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 viewPos = GetViewSpacePos(uv, fDepth);
    
    // Light Direction in View Space
    float3 lightDirVS = mul((float3x3)_WorldToCameraMatrix, normalize(_MainLightDirection.xyz));
    
    float shadow = RaymarchShadow(viewPos, lightDirVS, _SSCS_Distance, id.xy);
    
    _Result_SSCS[id.xy] = shadow;
}

// ------------------------------------------------
// SSR 전용 연산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSR (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;

    float smoothness = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);
    float linearDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 worldPos = GetViewSpacePos(uv, linearDepth);
    
    float3 reflectionColor = 0;
    if (smoothness > 0.01)
    {
        float3 viewNormal = mul((float3x3)_WorldToCameraMatrix, normalWS);
        float3 viewPosVS = mul(_WorldToCameraMatrix, float4(mul(_CameraToWorldMatrix, float4(worldPos, 1.0)).xyz, 1.0)).xyz;
        float3 vPos = worldPos; // This is VS pos
        float3 reflectDirVS = reflect(normalize(vPos), viewNormal);
        
        // Jittering 추가: Smoothness에 반비례하여 반사 벡터를 흔듦
        float roughness = saturate(1.0 - smoothness);
        if (roughness > 0.01)
        {
            uint seed = id.y * uint(_LNSurface_ScreenParams.x) + id.x;
            float3 jitter = float3(
                Local_Hash(seed) * 2.0 - 1.0,
                Local_Hash(seed + 100) * 2.0 - 1.0,
                Local_Hash(seed + 200) * 2.0 - 1.0
            );
            // Roughness가 클수록 Jitter 강도 증가 (0.0 ~ 0.1 범위)
            reflectDirVS = normalize(reflectDirVS + jitter * roughness * 0.1);
        }
        
        // Bias 추가: Self-Intersection 방지
        float3 startPos = vPos + reflectDirVS * 0.05;

        float2 hitUV;
        bool hitBack;
        if (Raymarch(startPos, reflectDirVS, _SSR_StepSize, hitUV, hitBack))
        {
            float hitMask = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).r;
            if (hitMask > 0.1 || hitBack) 
            {
                if (hitBack)
                    reflectionColor = _LNSurface_Back_Color.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
                else
                {
                    reflectionColor = _SceneColor.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
                }
                
                // Firefly Reduction (Clamp)
                reflectionColor = min(reflectionColor, 10.0);

                float2 edge = smoothstep(0, 0.2, hitUV) * smoothstep(1, 0.8, hitUV); // Edge Fade 강화
                reflectionColor *= edge.x * edge.y;
            }
        }
    }
    _Result_SSR[id.xy] = float4(reflectionColor, 1.0);
}

// ------------------------------------------------
// SSR 전용 Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSR_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 centerCol = _SSR_Raw[id.xy].rgb;
    float smoothness = _LNSurface_Front_Extra.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float roughness = saturate(1.0 - smoothness);
    
    float3 totalSSR = 0;
    float totalWeight = 0;

    // Roughness에 비례하는 가변 반경 설정 (대폭 증가)
    int radius = (int)lerp(0.0, 16.0, roughness);
    
    // Gaussian Sigma도 Roughness에 따라 조절
    float sigma = max(0.1, radius / 2.0);

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(clamp(id.x + x, 0, _LNSurface_ScreenParams.x - 1), clamp(id.y + y, 0, _LNSurface_ScreenParams.y - 1));
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float3 sampleCol = _SSR_Raw[sampleId].rgb;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            // Gaussian Spatial Weight
            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            
            // Binary Depth Weight: 깊이 차이가 0.01 미만이면 1, 아니면 0
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.01) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;

            totalSSR += sampleCol * weight;
            totalWeight += weight;
        }
    }

    _Result_SSR[id.xy] = float4(totalSSR / max(0.0001, totalWeight), 1.0);
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // 화면 범위를 벗어나는 스레드 제외
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    // 1. GBuffer 데이터 읽기 및 압축 해제
    float4 gbufferPacked = _LNSurface_Front_Packed[id.xy];
    float4 gbufferExtra = _LNSurface_Front_Extra[id.xy];
    float4 gbufferExtra2 = _LNSurface_Front_Extra2[id.xy];
    
    // 마스크 체크 (렌더링 대상이 아닌 배경 처리)
    float mask = gbufferExtra.r;
    if (mask <= 0.001)
    {
        _Result[id.xy] = _SceneColor[id.xy]; 
        return;
    }

    float4 gbuffer0 = _LNSurface_Front_Color[id.xy];
    
    float3 albedo = gbuffer0.rgb;
    float metallic = gbufferExtra.g;
    float smoothness = gbufferExtra.b;
    
    // Extra2에서 데이터 읽기
    float shadow = gbufferExtra2.r;
    
    // G채널 언패킹 (Subsurface, Anisotropic)
    float packedG = gbufferExtra2.g * 255.0;
    float subsurface = floor(packedG / 16.0) / 15.0;
    float anisotropic = (packedG - floor(packedG / 16.0) * 16.0) / 15.0;
    
    // B채널 언패킹 (SSS Intensity, SSS Thickness)
    float packedB = gbufferExtra2.b * 255.0;
    float sssIntensity = floor(packedB / 16.0) / 15.0 * 10.0; // 0~10 범위로 복원
    float sssThickness = (packedB - floor(packedB / 16.0) * 16.0) / 15.0 * 100.0; // 0~100 범위로 복원
    
    // Specular Strength, DiffuseWrap 등은 현재 Extra 텍스처에서 제거됨 (필요 시 복구 또는 상수 처리)
    float specularStrength = _SpecularStrength; // Global Setting
    float diffuseWrap = _DiffuseWrap; // Global Setting
    
    // Normal 복원
    float3 normalWS = DecodeNormal(gbufferPacked.rg);
    
    // 2. 월드 공간 좌표 재구성
    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float linearDepth = gbufferPacked.b;
    
    float3 viewPos = GetViewSpacePos(uv, linearDepth);
    float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
    
    // 카메라 위치 추출 및 시선 방향 계산
    float3 cameraPosWS = float3(_CameraToWorldMatrix._m03, _CameraToWorldMatrix._m13, _CameraToWorldMatrix._m23);
    float3 viewDir = normalize(cameraPosWS - worldPos);

    float3 totalDiffuse = 0;
    float3 totalSpecular = 0;
    float3 totalSSS = 0;
    
    // SSCS 적용 (Contact Shadow)
    if (_EnableSSCS > 0.5)
    {
        float sscs = _SSCS_Texture.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
        shadow = min(shadow, sscs);
    }

    // 3. 조명 루프 (메인 라이트 + 추가 라이트)
    uint lightLoopCount = (uint)(_AdditionalLightCount + 1);
    for (uint i = 0; i < lightLoopCount; ++i)
    {
        float3 lightColor;
        float3 lightDir;
        float atten = 1.0;

        if (i == 0) // 메인 라이트 처리
        {
            lightDir = normalize(_MainLightDirection.xyz);
            lightColor = _MainLightColor.rgb;
            atten = shadow; // 그림자 데이터 적용
        }
        else // 추가 점광원/스포트 라이트 처리
        {
            uint lightIdx = i - 1;
            float3 lightPos = _AdditionalLightPositions[lightIdx].xyz;
            float3 lightToPos = lightPos - worldPos;
            float distToLight = length(lightToPos); // 거리 계산
            lightDir = normalize(lightToPos);
            atten = GetDistanceAttenuation(lightToPos, _AdditionalLightAttenuations[lightIdx]);
            lightColor = _AdditionalLightColors[lightIdx].rgb;
            
            // SSCS 적용 (추가 라이트)
            if (_EnableSSCS > 0.5)
            {
                float3 lightDirVS = mul((float3x3)_WorldToCameraMatrix, lightDir);
                // 광원까지의 거리와 설정된 최대 거리 중 작은 값을 사용
                float rayDist = min(_SSCS_Distance, distToLight);
                float sscs = RaymarchShadow(viewPos, lightDirVS, rayDist, id.xy);
                atten *= sscs;
            }
        }

        // Diffuse Wrap (확산광이 반대편까지 부드럽게 감싸는 효과)
        float rawNdotL = dot(normalWS, lightDir);
        float NdotL = saturate((rawNdotL + diffuseWrap) / (1.0 + diffuseWrap));
        
        // --- Stylized Shadow Tint 적용 ---
        float3 shadowTintCol = GetShadowColor(lightColor);
        
        // 그림자 강도 (NdotL과 Attenuation을 모두 고려)
        // NdotL이 낮거나(어두운 면) Atten이 낮으면(그림자) 0에 가까워짐
        // diffuseWrap을 고려하여 마스크 생성
        float shadowMask = (rawNdotL + diffuseWrap) / (1.0 + diffuseWrap);
        shadowMask *= atten; // 그림자(Atten)가 있는 곳도 어둡게 처리
        
        // 0~1 범위로 부드럽게 매핑 (ShadowThreshold 적용)
        // _ShadowThreshold가 0.5일 때 기본 범위 (0.0 ~ 0.5)
        // _ShadowThreshold가 1.0일 때 주광 최대 범위 (-0.5 ~ 0.0)
        // _ShadowThreshold가 0.0일 때 그림자 최대 범위 (0.5 ~ 1.0)
        float minThreshold = 0.5 - _ShadowThreshold;
        float maxThreshold = 1.0 - _ShadowThreshold;
        float tintFactor = smoothstep(minThreshold, maxThreshold, shadowMask);
        
        // 밝은 부분은 원래 빛 색상, 어두운 부분은 틴트 색상으로 보간
        float3 litColor = lightColor * atten;
        float3 shadowColor = shadowTintCol * _ShadowTintIntensity;
        
        // 단순 RGB Lerp로 복구
        float3 mixedLightColor = lerp(shadowColor, litColor, tintFactor);

        if (_LightingModel == 0) // Half Lambert (카툰/회화적 연출)
        {
            // Half Lambert는 이미 NdotL을 변형하므로, 여기서는 Tint된 LightColor를 사용
            float halfLambert = rawNdotL * 0.5 + 0.5;
            totalDiffuse += albedo * halfLambert * mixedLightColor;
        }
        else // Disney BRDF (물리 기반 셰이딩)
        {
            float roughness = 1.0 - smoothness;
            roughness = max(roughness * roughness, 0.001);
            float alpha = roughness; 
            
            float3 halfDir = normalize(lightDir + viewDir);
            float NdotV = saturate(abs(dot(normalWS, viewDir)) + 1e-5);
            float NdotH = saturate(dot(normalWS, halfDir));
            float LdotH = saturate(dot(lightDir, halfDir));
            
            // Disney Diffuse & Subsurface Diffuse (모델 내 근사)
            float FD90 = 0.5 + 2.0 * smoothness * LdotH * LdotH;
            float lightScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotL);
            float viewScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotV);
            float baseDiffuse = lightScatter * viewScatter;

            float FSS90 = LdotH * LdotH * smoothness;
            float FSS = (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotL)) * 
                        (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotV));
            float ssDiffuse = 1.25 * (FSS * (1.0 / (NdotL + NdotV + 0.0001) - 0.5) + 0.5);

            float finalDiffuseFactor = lerp(baseDiffuse, ssDiffuse, subsurface);
            
            // Diffuse Term에 mixedLightColor 적용 (NdotL은 mixedLightColor의 그라데이션에 이미 반영됨)
            // 하지만 물리 기반 느낌을 살리기 위해 NdotL을 한번 더 곱해주는 것이 자연스러울 수 있음
            // 여기서는 Stylized 느낌을 위해 NdotL을 직접 곱하지 않고 mixedLightColor에 의존
            float3 diffuseTerm = albedo * finalDiffuseFactor * mixedLightColor; 
            
            totalDiffuse += diffuseTerm * (1.0 - metallic);
            
            // Specular (GTR2/GGX 기반) - 스펙큘러는 광원 색상을 그대로 따라야 함 (Tint 제외)
            float D = Local_GTR2(NdotH, alpha);
            float3 F0 = lerp(0.08 * specularStrength * float3(1,1,1), albedo, metallic);
            float FH = Local_SchlickFresnel(LdotH);
            float3 F = lerp(F0, float3(1,1,1), FH);
            float G = Local_G_Smith(NdotV, NdotL, 0.25);
            
            float3 specTerm = (D * F * G) / (4.0 * NdotL * NdotV + 0.0001);
            totalSpecular += max(0, specTerm) * lightColor * NdotL * PI * atten;
        }

        // 4. 투과형 하부표면 산란 (Translucency SSS)
        if (_EnableSSS > 0.5)
        {
            float frontDepth = gbufferPacked.b;
            float backDepth = _LNSurface_Back_Packed[id.xy].b;
            
            // Back Depth 유효성 검사 (빈 공간 또는 오류 처리)
            if (backDepth > 900.0 || backDepth < 0.001 || backDepth <= frontDepth)
            {
                backDepth = 10000.0; // 무한대 두께로 취급
            }
            
            float thickness = max(0, backDepth - frontDepth) * sssThickness;
            
            // 라이트가 뒤에서 비칠 때의 산란 강도 계산
            float backLightFactor = saturate((-rawNdotL + 0.2) * 2.0); 
            
            // SSS Intensity를 밝기 Multiplier로 사용
            float attenuation = exp(-thickness);
            totalSSS += attenuation * albedo.rgb * lightColor * backLightFactor * atten * sssIntensity;
        }
    }

    // 주변광 (Ambient / SH) 계산
    float3 ambientColor = SampleSH(normalWS) * albedo * (1.0 - metallic);

    // --- SSGI 적용 (간접광) ---
    if (_EnableSSGI > 0.5)
    {
        // Half-Res SSGI 텍스처를 Full-Res UV로 샘플링 (Linear Interpolation)
        float3 ssgi = _LNSurface_SSGI_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).rgb;
        ambientColor += ssgi * albedo * _SSGI_Intensity * (1.0 - metallic);
    }

    // --- SSAO 적용 (볼륨 차폐광) ---
    float ao = 1.0;
    if (_EnableSSAO > 0.5)
    {
        // Half-Res AO 텍스처를 Full-Res UV로 샘플링 (Linear Interpolation)
        float rawAO = _LNSurface_AO_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
        ao = saturate(1.0 - rawAO * _SSAO_Intensity);
    }
    ambientColor *= ao;

    // --- 화면 공간 반사 (SSR) 적용 ---
    float3 reflectionColor = 0;
    if (_EnableSSR > 0.5 && smoothness > 0.01)
    {
        // Half-Res SSR 텍스처를 Full-Res UV로 샘플링 (Linear Interpolation)
        reflectionColor = _LNSurface_SSR_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).rgb;
    }
    
    // 프레넬 법칙에 따른 환경광 및 반사광 합성
    float3 specColor = lerp(float3(0.04, 0.04, 0.04), albedo.rgb, metallic);
    float3 F = specColor + (1.0 - specColor) * Local_SchlickFresnel(max(dot(normalWS, viewDir), 0.0));
    
    // Roughness에 따른 반사광 블렌딩 (거칠수록 반사광이 약해짐)
    float roughness = saturate(1.0 - smoothness);
    
    // SSR Fade: Smoothness가 낮을수록(거칠수록) 반사를 부드럽게 끔
    float ssrFade = smoothstep(0.05, 0.2, smoothness);
    
    // Reflection Strength: 거칠수록 반사 강도 감소 (제곱 감쇠)
    float reflectionStrength = (1.0 - roughness);
    reflectionStrength *= reflectionStrength; 
    
    ambientColor += reflectionColor * F * reflectionStrength * ssrFade;

    // 최종 픽셀 컬러 출력 (확산광 + 주변광/반사광 + 스펙큘러 + SSS)
    _Result[id.xy] = float4(totalDiffuse + ambientColor + totalSpecular + totalSSS, 1.0);
}
