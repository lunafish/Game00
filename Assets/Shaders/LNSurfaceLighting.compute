#pragma kernel CSMain
#pragma kernel CS_SSAO_SSCS
#pragma kernel CS_SSAO_SSCS_Blur
#pragma kernel CS_SSR
#pragma kernel CS_SSR_Blur
#pragma kernel CS_SSGI
#pragma kernel CS_SSGI_Blur
#pragma kernel CS_TemporalReprojection
#pragma kernel CS_HiZ_Initialize
#pragma kernel CS_HiZ_Downsample

// 최종 결과를 저장할 렌더 타겟
RWTexture2D<float4> _Result;
RWTexture2D<float2> _Result_AO_SSCS; // SSAO(R) + SSCS(G) 통합 용

// --- 입력 텍스처 (GBuffer 자료형) ---
Texture2D<float4> _LNSurface_Front_Color;    // RGB: 알베도(Albedo), A: 1.0 (GBuffer0)
Texture2D<float4> _LNSurface_Front_Packed;   // RG: Oct-Encoded Normal, B: Linear Depth, A: Mask (GBuffer1)
Texture2D<float4> _LNSurface_Front_GBuffer2; // R: Metallic, G: Smoothness, B: Shadow, A: Packed Sub/Aniso
Texture2D<float4> _LNSurface_Front_GBuffer3; // R: Inner Height, G: Inner Normal X, B: Inner Normal Y, A: Packed SSS Int/Thick
Texture2D<float4> _LNSurface_Front_GBuffer4; // R: Inner Color(Packed), G: Thick/IOR, B: Blend/Fade, A: Unused

Texture2D<float4> _LNSurface_Back_Color;   // RGB: 뒷면 컬러
Texture2D<float4> _LNSurface_Back_Packed;  // RG: Oct-Encoded Normal, B: Linear Depth, A: 미사용

Texture2D<float4> _SceneColor;             // 배경 씬 컬러 (SSR 반사 소스)

Texture2D<float2> _AO_SSCS_Raw;                // 블러 전 SSAO+SSCS 소스
Texture2D<float2> _LNSurface_AO_SSCS_Blurred; // 블러 후 최종 SSAO+SSCS

RWTexture2D<float4> _Result_SSR; // SSR 용 (HDR)
Texture2D<float4> _SSR_Raw;               // 블러 전 SSR 소스
Texture2D<float4> _LNSurface_SSR_Blurred; // 블러 후 최종 SSR

RWTexture2D<float4> _Result_SSGI; // SSGI 용 (HDR)
Texture2D<float4> _SSGI_Raw;               // 블러 전 SSGI 소스
Texture2D<float4> _LNSurface_SSGI_Blurred; // 블러 후 최종 SSGI

// --- Temporal Reprojection Resources ---
Texture2D<float4> _HistoryBuffer; // 이전 프레임 결과 (Read)
RWTexture2D<float4> _NewHistoryBuffer; // 다음 프레임용 저장 (Write)
Texture2D<float4> _CurrentFrameResult; // 현재 프레임 결과 (Noisy)

// --- Hi-Z Resources ---
RWTexture2D<float> _HiZ_Source;
RWTexture2D<float> _HiZ_Destination;
Texture2D<float> _HiZ_Pyramid; // SSR/SSGI에서 참조할 최종 피라미드 (밉맵)

SamplerState painter_linear_clamp_sampler;
SamplerState painter_point_clamp_sampler;

// --- 전역 파라미터 ---
float2 _LNSurface_ScreenParams;     // 화면 해상도 (이름 변경)
float4 _MainLightDirection; // 메인 라이트 방향
float4 _MainLightColor;     // 메인 라이트 색상 및 강도
int _AdditionalLightCount;  // 추가 라이트 개수 (최대 16)
float4 _AdditionalLightPositions[16];
float4 _AdditionalLightColors[16];
float4 _AdditionalLightAttenuations[16]; // x: 거리 감쇠 역제곱, y: 미사용

// 하부표면 산란(SSS) 설정
float _SSS_Intensity;     // SSS 강도
float _SSS_ThicknessScale; // 두께 계수
float _EnableSSS;          // SSS 활성화 여부

// 구면 조화 함수(SH) - Ambient Light 연산용
float4 unity_SHAr, unity_SHAg, unity_SHAb;
float4 unity_SHBr, unity_SHBg, unity_SHBb;
float4 unity_SHC;

// 행렬 데이터
float4x4 _InverseProjectionMatrix; // 뷰 공간 재구성을 위한 투영 역행렬
float4x4 _CameraToWorldMatrix;      // 뷰 -> 월드 변환
float4x4 _WorldToCameraMatrix;      // 월드 -> 뷰 변환
float4x4 _ProjectionMatrix;         // 월드 -> 클립 변환
float4x4 _PrevViewProjMatrix;       // 이전 프레임 View-Projection 행렬 (Velocity 계산용)
int _LightingModel; // 조명 모델 선택 (0: HalfLambert, 1: DisneyBRDF)

// Material Global Settings
float _SpecularStrength;
float _DiffuseWrap;

// Shadow Tint Settings
int _ShadowTintMode; // 0: Custom, 1: Complementary
float4 _ShadowTintColor;
float _ShadowTintIntensity;
float _ShadowThreshold; // 0.0 ~ 1.0

// Inner POM Settings
float _EnableInnerPOM;
// Per-pixel params are now in GBuffer

// 화면 공간 반사(SSR) 설정
float _EnableSSR;      // SSR 활성화 여부
int _SSR_MaxSteps;     // 최대 레이마칭 단계
float _SSR_StepSize;    // 레이 전진 보폭
float _SSR_Thickness;   // 충돌 판정 두께 임계값
int _DebugMode;         // 디버그 시각화 모드

// --- SSAO (Screen Space Ambient Occlusion) 설정 ---
float _EnableSSAO;      // SSAO 활성화 여부
float _SSAO_Radius;     // 차폐 탐색 반경
float _SSAO_Intensity;  // 차폐 강도
int _SSAO_SampleCount;  // 샘플 개수 (4~32 권장)

// --- SSGI (Screen Space Global Illumination) 설정 ---
float _EnableSSGI;
float _SSGI_Intensity;
int _SSGI_SampleCount;
int _SSGI_MaxSteps; // Added
float _SSGI_RayStepSize;

// --- SSCS (Screen Space Cast Shadow) 설정 ---
float _EnableSSCS;
float _SSCS_Distance;
int _SSCS_MaxSteps;
float _SSCS_Thickness;
float _SSCS_Intensity; // SSCS 강도 추가

// Checkerboard Rendering Settings
float _EnableCheckerboard;
int _FrameCount;

// Hi-Z Settings
int _HiZ_MaxMip;

// Backface Raymarching Option
float _UseBackfaceRaymarching;

#ifndef PI
#define PI 3.14159265359f
#endif

// --- Helper Functions ---

float2 OctWrap(float2 v)
{
    return (1.0 - abs(v.yx)) * (v.xy >= 0.0 ? 1.0 : -1.0);
}

float3 DecodeNormal(float2 f)
{
    f = f * 2.0 - 1.0;
    float3 n = float3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
    float t = saturate(-n.z);
    n.xy += n.xy >= 0.0 ? -t : t;
    return normalize(n);
}

// --- Color Utility Functions (HSV) ---
float3 RGBtoHSV(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 HSVtoRGB(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float3 GetShadowColor(float3 lightColor)
{
    if (_ShadowTintMode == 0) // Custom
    {
        return _ShadowTintColor.rgb;
    }
    else // Complementary (HSV Hue Shift)
    {
        float3 hsv = RGBtoHSV(lightColor);
        hsv.x = frac(hsv.x + 0.5); // 180도 회전
        
        float saturationFactor = 0.7;
        // 보색의 채도를 주광원 채도의 70%로 낮춤 (최소값 0.1 보장)
        hsv.y = max(hsv.y * saturationFactor, 0.1); 
        
        // 명도(Value)도 채도가 빠지는 만큼 어둡게 (70% 수준)
        hsv.z *= saturationFactor;
        
        return HSVtoRGB(hsv);
    }
}

// --- Disney BRDF 유틸리티 함수 ---
float Local_Sqr(float x) { return x * x; }

// Schlick Fresnel 근사식
float Local_SchlickFresnel(float u)
{
    float m = clamp(1.0 - u, 0.0, 1.0);
    float m2 = m * m;
    return m2 * m2 * m; // pow(m, 5)
}

// GTR2 분포 함수 (GGX 코어)
float Local_GTR2(float NdotH, float a)
{
    float a2 = a * a;
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

// Smith 기하 차폐 함수 (Smith Geometric Shadowing)
float Local_G_Smith(float NdotV, float NdotL, float alpha)
{
    float a = Local_Sqr(alpha);
    float k = Local_Sqr(alpha + 1.0) * 0.125; // 직접 조명 모드
    float g1 = NdotV / (NdotV * (1.0 - k) + k);
    float g2 = NdotL / (NdotL * (1.0 - k) + k);
    return g1 * g2;
}

// 점광원 거리 감쇠 계산
float GetDistanceAttenuation(float3 lightDir, float4 attenuation)
{
    float d2 = dot(lightDir, lightDir);
    float rangeCheck = saturate(1.0 - d2 * attenuation.x);
    return rangeCheck * rangeCheck / (d2 + 0.01);
}

// Unity의 ShadeSH9과 동일한 방식으로 Ambient(주변광) 계산
float3 SampleSH(float3 normal)
{
    float4 n = float4(normal, 1.0);
    float3 x1, x2, x3;
    
    x1.r = dot(unity_SHAr, n);
    x1.g = dot(unity_SHAg, n);
    x1.b = dot(unity_SHAb, n);
    
    float4 vB = n.xyzz * n.yzzx;
    x2.r = dot(unity_SHBr, vB);
    x2.g = dot(unity_SHBg, vB);
    x2.b = dot(unity_SHBb, vB);
    
    float vC = n.x * n.x - n.y * n.y;
    x3 = unity_SHC.rgb * vC;
    
    return max(0, x1 + x2 + x3);
}

// --- SSR 헬퍼 함수 ---

// 선형 깊이와 UV를 사용하여 뷰 공간(View Space) 좌표 복구
float3 GetViewSpacePos(float2 uv, float linearDepth)
{
    float fovScaleX = _InverseProjectionMatrix._m00;
    float fovScaleY = _InverseProjectionMatrix._m11;
    
    float4 clipPos;
    clipPos.xy = uv * 2.0 - 1.0;
    clipPos.z = 0; 
    clipPos.w = 1;

    float3 viewPos;
    viewPos.z = -linearDepth; 
    viewPos.x = clipPos.x * fovScaleX * -viewPos.z; 
    viewPos.y = clipPos.y * fovScaleY * -viewPos.z;
    return viewPos;
}

// 뷰 공간 좌표를 다시 화면 UV 좌표로 투영
float3 ProjectViewPos(float3 viewPos)
{
    float4 clipPos = mul(_ProjectionMatrix, float4(viewPos, 1.0));
    float3 ndcPos = clipPos.xyz / clipPos.w;
    return float3(ndcPos.xy * 0.5 + 0.5, ndcPos.z);
}

// --- SSAO/SSGI 헬퍼 함수 ---

// 해시 기반 의사 난수 생성기 (샘플링 위치 지터링용)
float Local_Hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return (float)seed / 4294967296.0;
}

void GetOrthonormalBasis(float3 n, out float3 tangent, out float3 bitangent)
{
    float3 up = abs(n.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
    tangent = normalize(cross(up, n));
    bitangent = cross(n, tangent);
}

float3 GetCosineHemisphereDir(float3 n, uint seed)
{
    float2 rand = float2(Local_Hash(seed), Local_Hash(seed + 114));
    float r = sqrt(rand.x);
    float phi = 2.0 * PI * rand.y;
    
    float3 localDir = float3(r * cos(phi), r * sin(phi), sqrt(max(0.0, 1.0 - rand.x)));
    
    float3 t, b;
    GetOrthonormalBasis(n, t, b);
    
    return t * localDir.x + b * localDir.y + n * localDir.z;
}

/**
 * 볼륨 기반 SSAO 연산 (Back Depth 활용)
 * @param posWS: 현재 픽셀의 월드 공간 위치
 * @param normalWS: 현재 픽셀의 월드 공간 노멀
 * @param pixId: 현재 스레드 ID (픽셀 좌표)
 */
float CalculateSSAO(float3 posWS, float3 normalWS, uint2 pixId)
{
    if (_EnableSSAO < 0.5) return 0.0;

    // 뷰 공간 데이터로 변환
    float3 viewNormal = mul((float3x3)_WorldToCameraMatrix, normalWS);
    float3 viewPos = mul(_WorldToCameraMatrix, float4(posWS, 1.0)).xyz;
    
    float occlusion = 0;
    int samples = _SSAO_SampleCount;
    
    for (int i = 0; i < samples; i++)
    {
        // 픽셀 좌표와 인덱스를 조합한 시드 생성
        uint seedInput = pixId.y * uint(_LNSurface_ScreenParams.x) + pixId.x + uint(i);
        float3 randVec = float3(
            Local_Hash(seedInput),
            Local_Hash(seedInput + 100),
            Local_Hash(seedInput + 200)
        ) * 2.0 - 1.0;
        
        randVec = normalize(randVec);
        
        // 반구(Hemisphere) 방향으로 정렬
        if (dot(randVec, viewNormal) < 0) randVec = -randVec;
        
        // 탐색 반경 내 무작위 지점 선정
        float weight = (float)i / (float)samples;
        float3 samplePosVS = viewPos + randVec * _SSAO_Radius * (0.1 + 0.9 * Local_Hash(seedInput + 300));
        
        // 화면 공간 투영 및 깊이 비교
        float3 sampleScreenPos = ProjectViewPos(samplePosVS);
        
        if (sampleScreenPos.x >= 0 && sampleScreenPos.x <= 1 && sampleScreenPos.y >= 0 && sampleScreenPos.y <= 1)
        {
            // Half-Res 최적화: UV 샘플링 사용
            float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleScreenPos.xy, 0).b;
            float bDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, sampleScreenPos.xy, 0).b;
            float sampleDepth = -samplePosVS.z;
            
            // 볼륨 기반 체크: 샘플이 실제 물체 내부(Front ~ Back)에 있는가?
            // 뒷면 데이터가 없을 경우(bDepth <= fDepth)를 대비해 fDepth 이후 일정 거리를 물체로 간주
            float effectiveBackDepth = (bDepth > fDepth + 0.001) ? bDepth : (fDepth + 0.1); 
            
            if (sampleDepth >= fDepth + 0.01 && sampleDepth <= effectiveBackDepth + 0.05)
            {
                // 인접성 기반 가중치 (너무 멀리 있는 벽은 무시)
                // -viewPos.z (현재 깊이)와 fDepth (샘플 지점의 실제 깊이) 비교
                float rangeCheck = smoothstep(1.0, 0.0, abs(-viewPos.z - fDepth) / _SSAO_Radius);
                occlusion += rangeCheck;
            }
        }
    }
    
    // 가중치 평균 리턴 (0: 차폐 없음, 1: 최대 차폐)
    return saturate(occlusion / (float)samples);
}


/**
 * 정밀 SSR 레이마칭 엔진
 * @param startPosVS: 시작 위치 (뷰 공간)
 * @param rayDirVS: 반사 레이 방향 (뷰 공간)
 * @param stepSize: 레이 전진 보폭
 * @param maxSteps: 최대 레이마칭 단계 (Added)
 * @param hitUV: 충돌 시 화면 UV 결과값
 * @param hitBack: 뒷면(Back face) 충돌 여부
 */
bool Raymarch(float3 startPosVS, float3 rayDirVS, float stepSize, int maxSteps, out float2 hitUV, out bool hitBack)
{
    float3 rayPosVS = startPosVS;
    hitBack = false;
    hitUV = float3(0, 0, 0).xy; 

    float currentMip = 0.0;
    float maxDistance = 200.0; 
    float traveled = 0.0;

    float3 rayDir = normalize(rayDirVS);
    
    // Bias: 시작 위치를 표면에서 살짝 띄움 (Depth-dependent bias)
    // 기존: rayPosVS += rayDir * 0.05;
    // 수정: 깊이에 비례하여 바이어스 증가 (0.5% of depth)
    float startDepth = -startPosVS.z;
    float bias = max(0.05, startDepth * 0.005); 
    rayPosVS += rayDir * bias;

    // 이전 스텝 위치 저장용 (Binary Search를 위해)
    float3 prevRayPosVS = rayPosVS;

    [loop]
    for (int i = 0; i < maxSteps; i++)
    {
        // prevRayPosVS = rayPosVS; // <-- 여기가 아니라 이동 직전에 저장해야 함

        float3 screenPos = ProjectViewPos(rayPosVS);
        
        if (screenPos.x < 0.0 || screenPos.x > 1.0 || screenPos.y < 0.0 || screenPos.y > 1.0)
            return false;

        float frontDepth = _HiZ_Pyramid.SampleLevel(painter_point_clamp_sampler, screenPos.xy, currentMip).r;
        float rayDepth = -rayPosVS.z;

        // Hi-Z Traversal
        if (rayDepth < frontDepth - 0.01) 
        {
            // 빈 공간: 밉맵 레벨을 높여서 크게 점프
            float jumpMultiplier = pow(2.0, floor(currentMip));
            float jump = stepSize * jumpMultiplier;
            
            prevRayPosVS = rayPosVS; // <-- 이동 직전 위치 저장!
            rayPosVS += rayDir * jump;
            traveled += jump;
            currentMip = min((float)_HiZ_MaxMip, currentMip + 1.0);
        }
        else
        {
            // 충돌 가능성 있음
            if (currentMip <= 0.5)
            {
                // Mip 0: 정밀 검사 (Binary Search 추가)
                
                // 1. Binary Search (Refinement)
                // 레이가 표면을 뚫고 지나갔을 수 있으므로, 이전 위치와 현재 위치 사이를 이분 탐색
                float3 start = prevRayPosVS;
                float3 end = rayPosVS;
                float3 mid = start;
                
                for(int j=0; j<4; j++) // 4번 정도 반복하면 충분히 정밀해짐
                {
                    mid = (start + end) * 0.5;
                    float3 midScreenPos = ProjectViewPos(mid);
                    float midDepth = _HiZ_Pyramid.SampleLevel(painter_point_clamp_sampler, midScreenPos.xy, 0).r;
                    
                    if (-mid.z > midDepth) // 여전히 표면 뒤에 있다면
                        end = mid; // 범위를 앞쪽으로 좁힘
                    else
                        start = mid; // 표면 앞이라면 범위를 뒤쪽으로 좁힘
                }
                
                rayPosVS = mid; // 보정된 위치 사용
                screenPos = ProjectViewPos(rayPosVS);
                frontDepth = _HiZ_Pyramid.SampleLevel(painter_point_clamp_sampler, screenPos.xy, 0).r;
                rayDepth = -rayPosVS.z;

                // 2. 최종 충돌 판정
                float fDepth = frontDepth;
                
                if (_UseBackfaceRaymarching > 0.5)
                {
                    float bDepth = _LNSurface_Back_Packed.SampleLevel(painter_point_clamp_sampler, screenPos.xy, 0).b;
                    
                    bool hasBackFace = (bDepth > fDepth + 0.001) && (bDepth < 900.0);
                    float thickness = hasBackFace ? (bDepth - fDepth) : _SSR_Thickness;
                    
                    float adaptiveThickness = max(_SSR_Thickness, traveled * 0.005); // 계수 감소 (0.01 -> 0.005)
                    thickness = max(thickness, adaptiveThickness);

                    // 충돌 허용 오차 완화 (-0.02 -> -0.05)
                    // 수정: 깊이에 비례하여 오차 범위 조절 (0.2% of depth)
                    float depthTolerance = max(0.05, rayDepth * 0.002);

                    if (rayDepth >= fDepth - depthTolerance && rayDepth <= fDepth + thickness)
                    {
                        hitUV = screenPos.xy;
                        hitBack = hasBackFace && (abs(rayDepth - bDepth) < abs(rayDepth - fDepth));
                        return true;
                    }
                }
                else
                {
                    // Backface 미사용: Front Depth와 Thickness만 사용
                    float thickness = _SSR_Thickness;
                    float adaptiveThickness = max(_SSR_Thickness, traveled * 0.005);
                    thickness = max(thickness, adaptiveThickness);
                    
                    // 수정: 깊이에 비례하여 오차 범위 조절
                    float depthTolerance = max(0.05, rayDepth * 0.002);

                    if (rayDepth >= fDepth - depthTolerance && rayDepth <= fDepth + thickness)
                    {
                        hitUV = screenPos.xy;
                        hitBack = false; // Backface 충돌 없음
                        return true;
                    }
                }
                
                // 충돌이 아니라면 다시 전진 (Binary Search로 위치가 뒤로 갔을 수 있으므로 주의)
                // 여기서 루프가 꼬이지 않도록 강제로 조금 전진시킴
                prevRayPosVS = rayPosVS; // <-- 이동 직전 위치 저장!
                rayPosVS += rayDir * stepSize; 
                traveled += stepSize;
            }
            else
            {
                // 더 낮은 밉맵 레벨로 내려가서 다시 검사
                currentMip = max(0.0, currentMip - 1.0);
                // 위치는 되돌리지 않음 (Hi-Z 특성상 현재 셀 안에 표면이 있을 수 있음)
            }
        }

        if (traveled > maxDistance) return false;
    }

    return false;
}


// --- SSCS Raymarching ---
float RaymarchShadow(float3 startPosVS, float3 lightDirVS, float maxDist, uint2 pixId)
{
    float3 currentPosVS = startPosVS;
    float stepSize = maxDist / (float)_SSCS_MaxSteps;
    float shadow = 1.0;
    
    // Jittering: 픽셀마다 시작 위치를 랜덤하게 이동하여 Banding 완화
    float dither = Local_Hash(pixId.y * uint(_LNSurface_ScreenParams.x) + pixId.x);
    currentPosVS += lightDirVS * stepSize * dither;
    
    // Bias: Self-Shadowing 방지용 Depth Bias (0.02 -> 0.005로 감소)
    float bias = 0.005; 

    for (int i = 0; i < _SSCS_MaxSteps; i++)
    {
        currentPosVS += lightDirVS * stepSize;
        
        float3 screenPos = ProjectViewPos(currentPosVS);
        if (screenPos.x < 0 || screenPos.x > 1 || screenPos.y < 0 || screenPos.y > 1)
            break; // 화면 밖으로 나가면 그림자 없음 (빛)
            
        float frontDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        float backDepth = _LNSurface_Back_Packed.SampleLevel(painter_linear_clamp_sampler, screenPos.xy, 0).b;
        float currentDepth = -currentPosVS.z;
        
        // Back Depth 유효성 체크
        bool hasBackFace = (backDepth < 900.0);
        float thickness = hasBackFace ? (backDepth - frontDepth) : _SSCS_Thickness;
        thickness = max(thickness, _SSCS_Thickness);

        // 레이가 물체 뒤로 들어갔는지 확인 (Occlusion)
        // Bias를 적용하여 자기 자신의 표면 바로 뒤는 무시
        if (currentDepth > frontDepth + bias && currentDepth < frontDepth + thickness)
        {
            shadow = 0.0; // 가려짐
            break;
        }
    }
    
    // 강도 적용 (0: 완전 그림자, 1: 그림자 없음) -> lerp(1, shadow, intensity)
    return lerp(1.0, shadow, _SSCS_Intensity);
}

// ------------------------------------------------
// SSAO + SSCS 통합 계산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSAO_SSCS (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float mask = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).a;
    
    float ao = 0.0;
    float sscs = 1.0;

    if (mask > 0.001)
    {
        float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
        float3 viewPos = GetViewSpacePos(uv, fDepth);
        
        if (_EnableSSAO > 0.5)
        {
            float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
            float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);
            ao = CalculateSSAO(worldPos, normalWS, id.xy);
        }
        
        if (_EnableSSCS > 0.5)
        {
            float3 lightDirVS = mul((float3x3)_WorldToCameraMatrix, normalize(_MainLightDirection.xyz));
            sscs = RaymarchShadow(viewPos, lightDirVS, _SSCS_Distance, id.xy);
        }
    }

    _Result_AO_SSCS[id.xy] = float2(ao, sscs);
}

// ------------------------------------------------
// SSAO + SSCS 통합 Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSAO_SSCS_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float2 totalAO_SSCS = 0;
    float totalWeight = 0;

    // SSAO 반경을 기준으로 Blur (SSCS도 동일하게 공유)
    int radius = (int)lerp(1.0, 8.0, _SSAO_Radius);
    float sigma = max(0.1, radius / 2.0);

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(
                clamp(id.x + x, 0, (uint)_LNSurface_ScreenParams.x - 1),
                clamp(id.y + y, 0, (uint)_LNSurface_ScreenParams.y - 1)
            );
            
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float2 sampleAO_SSCS = _AO_SSCS_Raw[sampleId].rg;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            // Gaussian Spatial Weight
            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            
            // Binary Depth Weight: 깊이 차이가 0.01 미만이면 1, 아니면 0
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.01) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;
            
            totalAO_SSCS += sampleAO_SSCS * weight;
            totalWeight += weight;
        }
    }

    _Result_AO_SSCS[id.xy] = totalAO_SSCS / max(0.0001, totalWeight);
}

bool IsCheckerboardPixel(uint2 pixId)
{
    return (pixId.x + pixId.y) % 2 == (uint)_FrameCount % 2;
}

// ------------------------------------------------
// SSGI 전용 계산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSGI (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;

    if (_EnableCheckerboard > 0.5 && !IsCheckerboardPixel(id.xy))
    {
        _Result_SSGI[id.xy] = 0.0;
        return;
    }

    float mask = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).a;
    if (mask <= 0.001)
    {
        _Result_SSGI[id.xy] = 0.0;
        return;
    }

    float fDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 viewPos = GetViewSpacePos(uv, fDepth);
    
    float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);
    float3 normalVS = mul((float3x3)_WorldToCameraMatrix, normalWS);
    
    float3 indirectLight = 0;
    int samples = _SSGI_SampleCount;
    
    for(int i=0; i<samples; i++)
    {
        uint seed = id.y * uint(_LNSurface_ScreenParams.x) + id.x + uint(i * 152);
        float3 rayDirVS = GetCosineHemisphereDir(normalVS, seed);
        
        float2 hitUV;
        bool hitBack;
        
        if(Raymarch(viewPos, rayDirVS, _SSGI_RayStepSize, _SSGI_MaxSteps, hitUV, hitBack))
        {
            float3 hitColor;
            if (hitBack && _UseBackfaceRaymarching > 0.5)
            {
                hitColor = _LNSurface_Back_Color.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
            }
            else
            {
                hitColor = _SceneColor.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
            }
            indirectLight += hitColor;
        }
        else
        {
            // Fallback: Ambient (Sky) Light
            float3 rayDirWS = mul((float3x3)_CameraToWorldMatrix, rayDirVS);
            indirectLight += SampleSH(rayDirWS);
        }
    }
    
    _Result_SSGI[id.xy] = float4(indirectLight / max(1, samples), 1.0);
}

// ------------------------------------------------
// SSGI Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSGI_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 totalColor = 0;
    float totalWeight = 0;

    int radius = 4;
    float sigma = 2.0;

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(
                clamp(id.x + x, 0, (uint)_LNSurface_ScreenParams.x - 1),
                clamp(id.y + y, 0, (uint)_LNSurface_ScreenParams.y - 1)
            );
            
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float3 sampleColor = _SSGI_Raw[sampleId].rgb;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.05) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;
            
            // Checkerboard Awareness: Skip zero pixels if enabled
            if (_EnableCheckerboard > 0.5 && any(sampleColor > 0))
            {
                totalColor += sampleColor * weight;
                totalWeight += weight;
            }
            else if (_EnableCheckerboard <= 0.5)
            {
                totalColor += sampleColor * weight;
                totalWeight += weight;
            }
        }
    }

    _Result_SSGI[id.xy] = float4(totalColor / max(0.0001, totalWeight), 1.0);
}


// ------------------------------------------------
// SSR 전용 연산 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSR (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;

    if (_EnableCheckerboard > 0.5 && !IsCheckerboardPixel(id.xy))
    {
        _Result_SSR[id.xy] = 0.0;
        return;
    }

    float smoothness = _LNSurface_Front_GBuffer2.SampleLevel(painter_linear_clamp_sampler, uv, 0).g;
    float3 normalWS = DecodeNormal(_LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).rg);
    float linearDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 worldPos = GetViewSpacePos(uv, linearDepth);
    
    float3 reflectionColor = 0;
    if (smoothness > 0.01)
    {
        float3 viewNormal = mul((float3x3)_WorldToCameraMatrix, normalWS);
        float3 viewPosVS = mul(_WorldToCameraMatrix, float4(mul(_CameraToWorldMatrix, float4(worldPos, 1.0)).xyz, 1.0)).xyz;
        float3 vPos = worldPos; // This is VS pos
        float3 reflectDirVS = reflect(normalize(vPos), viewNormal);
        
        // Jittering 추가: Smoothness에 반비례하여 반사 벡터를 흔듦
        float roughness = saturate(1.0 - smoothness);
        if (roughness > 0.01)
        {
            uint seed = id.y * uint(_LNSurface_ScreenParams.x) + id.x;
            float3 jitter = float3(
                Local_Hash(seed) * 2.0 - 1.0,
                Local_Hash(seed + 100) * 2.0 - 1.0,
                Local_Hash(seed + 200) * 2.0 - 1.0
            );
            // Roughness가 클수록 Jitter 강도 증가 (0.0 ~ 0.1 범위)
            reflectDirVS = normalize(reflectDirVS + jitter * roughness * 0.1);
        }
        
        // Bias 추가: Self-Intersection 방지
        float3 startPos = vPos + reflectDirVS * 0.05;

        float2 hitUV;
        bool hitBack;
        if (Raymarch(startPos, reflectDirVS, _SSR_StepSize, _SSR_MaxSteps, hitUV, hitBack))
        {
            float hitMask = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).a;
            if (hitMask > 0.1 || hitBack) 
            {
                if (hitBack && _UseBackfaceRaymarching > 0.5)
                    reflectionColor = _LNSurface_Back_Color.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
                else
                {
                    reflectionColor = _SceneColor.SampleLevel(painter_linear_clamp_sampler, hitUV, 0).rgb;
                }
                
                // Firefly Reduction (Clamp)
                reflectionColor = min(reflectionColor, 10.0);

                float2 edge = smoothstep(0, 0.2, hitUV) * smoothstep(1, 0.8, hitUV); // Edge Fade 강화
                reflectionColor *= edge.x * edge.y;
            }
        }
    }
    _Result_SSR[id.xy] = float4(reflectionColor, 1.0);
}

// ------------------------------------------------
// SSR 전용 Bilateral Blur 커널 (Half-Res)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_SSR_Blur (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float centerDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, uv, 0).b;
    float3 centerCol = _SSR_Raw[id.xy].rgb;
    float smoothness = _LNSurface_Front_GBuffer2.SampleLevel(painter_linear_clamp_sampler, uv, 0).g;
    float roughness = saturate(1.0 - smoothness);
    
    float3 totalSSR = 0;
    float totalWeight = 0;

    // Roughness에 비례하는 가변 반경 설정 (대폭 증가)
    int radius = (int)lerp(0.0, 16.0, roughness);
    
    // Gaussian Sigma도 Roughness에 따라 조절
    float sigma = max(0.1, radius / 2.0);

    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            uint2 sampleId = uint2(clamp(id.x + x, 0, _LNSurface_ScreenParams.x - 1), clamp(id.y + y, 0, _LNSurface_ScreenParams.y - 1));
            float2 sampleUV = (float2(sampleId) + 0.5) / _LNSurface_ScreenParams;

            float3 sampleCol = _SSR_Raw[sampleId].rgb;
            float sampleDepth = _LNSurface_Front_Packed.SampleLevel(painter_linear_clamp_sampler, sampleUV, 0).b;

            // Gaussian Spatial Weight
            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigma * sigma));
            
            // Binary Depth Weight: 깊이 차이가 0.01 미만이면 1, 아니면 0
            float depthWeight = (abs(centerDepth - sampleDepth) < 0.01) ? 1.0 : 0.0;
            
            float weight = spatialWeight * depthWeight;

            // Checkerboard Awareness: Skip zero pixels if enabled
            if (_EnableCheckerboard > 0.5 && any(sampleCol > 0))
            {
                totalSSR += sampleCol * weight;
                totalWeight += weight;
            }
            else if (_EnableCheckerboard <= 0.5)
            {
                totalSSR += sampleCol * weight;
                totalWeight += weight;
            }
        }
    }

    _Result_SSR[id.xy] = float4(totalSSR / max(0.0001, totalWeight), 1.0);
}

// ------------------------------------------------
// Temporal Reprojection 커널 (Denoising)
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_TemporalReprojection (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    
    // 1. 현재 프레임 결과 읽기
    float4 currentColor = _CurrentFrameResult[id.xy];
    
    // Checkerboard Reconstruction: If current pixel was skipped, use spatial neighbors
    if (_EnableCheckerboard > 0.5 && !IsCheckerboardPixel(id.xy))
    {
        float4 sum = 0;
        float totalW = 0;
        uint2 offsets[4] = { uint2(1, 0), uint2(-1, 0), uint2(0, 1), uint2(0, -1) };
        for(int i=0; i<4; i++)
        {
            uint2 nId = clamp(id.xy + offsets[i], 0, (uint2)_LNSurface_ScreenParams.xy - 1);
            float4 nCol = _CurrentFrameResult[nId];
            if (any(nCol > 0))
            {
                sum += nCol;
                totalW += 1.0;
            }
        }
        if (totalW > 0) currentColor = sum / totalW;
    }
    
    // 2. Velocity 계산 (Reconstruction)
    float depth = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv, 0).b;
    
    // 현재 프레임의 World Position 복원
    float3 viewPos = GetViewSpacePos(uv, depth);
    float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
    
    // 이전 프레임의 Clip Space 좌표 계산
    float4 prevClipPos = mul(_PrevViewProjMatrix, float4(worldPos, 1.0));
    float2 prevUV = (prevClipPos.xy / prevClipPos.w) * 0.5 + 0.5;
    
    // Velocity Vector
    float2 velocity = uv - prevUV;
    
    // 3. History 샘플링 위치 계산
    float2 historyUV = uv - velocity;
    
    // 4. 유효성 검사 (화면 밖으로 나갔는지)
    if (any(historyUV < 0.0 || historyUV > 1.0))
    {
        _NewHistoryBuffer[id.xy] = currentColor;
        return;
    }
    
    // 5. History 샘플링
    float4 historyColor = _HistoryBuffer.SampleLevel(painter_linear_clamp_sampler, historyUV, 0);
    
    // 6. Neighborhood Clamping (Ghosting 방지)
    // 현재 픽셀 주변 3x3 영역의 Min/Max 색상을 구해서 History를 그 범위 내로 자름
    float4 minColor = currentColor;
    float4 maxColor = currentColor;
    
    for(int x = -1; x <= 1; x++)
    {
        for(int y = -1; y <= 1; y++)
        {
            uint2 neighborId = uint2(
                clamp(id.x + x, 0, (uint)_LNSurface_ScreenParams.x - 1),
                clamp(id.y + y, 0, (uint)_LNSurface_ScreenParams.y - 1)
            );
            float4 neighborColor = _CurrentFrameResult[neighborId];
            minColor = min(minColor, neighborColor);
            maxColor = max(maxColor, neighborColor);
        }
    }
    
    historyColor = clamp(historyColor, minColor, maxColor);
    
    // 7. Blending (90% History, 10% Current)
    float velocityMag = length(velocity * _LNSurface_ScreenParams);
    float blendFactor = lerp(0.9, 0.5, saturate(velocityMag / 10.0));
    
    float4 finalColor = lerp(currentColor, historyColor, blendFactor);
    
    _NewHistoryBuffer[id.xy] = float4(finalColor.rgb, 1.0);
}

// ------------------------------------------------
// Hi-Z Depth Pyramid Initialization
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_HiZ_Initialize(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    float depth = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv, 0).b;
    _HiZ_Destination[id.xy] = depth;
}

// ------------------------------------------------
// Hi-Z Depth Pyramid Downsample Kernel
// ------------------------------------------------
[numthreads(8, 8, 1)]
void CS_HiZ_Downsample(uint3 id : SV_DispatchThreadID)
{
    uint2 srcId = id.xy * 2;
    
    // 2x2 픽셀 중 최소 깊이(Min-Depth) 선택
    float d0 = _HiZ_Source[srcId + uint2(0, 0)].r;
    float d1 = _HiZ_Source[srcId + uint2(1, 0)].r;
    float d2 = _HiZ_Source[srcId + uint2(0, 1)].r;
    float d3 = _HiZ_Source[srcId + uint2(1, 1)].r;
    
    float minDepth = min(min(d0, d1), min(d2, d3));
    
    _HiZ_Destination[id.xy] = minDepth;
}

// --- Inner POM Helper ---
float2 CalculateInnerPOM(float2 uv, float3 viewDirTS, float depthScale, uint2 pixId, bool useTriplanar, out float outLayerDepth)
{
    // 1. Linear Search (Coarse)
    int linearSteps = 10;
    float stepSize = 1.0 / (float)linearSteps;
    outLayerDepth = 0.0;
    
    float2 currentUV = uv;
    float2 deltaUV = viewDirTS.xy * depthScale / (float)linearSteps;
    
    // Jittering (Dithering) to reduce banding
    float jitter = Local_Hash(pixId.y * uint(_LNSurface_ScreenParams.x) + pixId.x);
    currentUV -= deltaUV * jitter;
    float currentLayerDepth = stepSize * jitter;
    
    float2 prevUV = currentUV;
    float prevLayerDepth = 0.0;
    float prevHeight = 1.0;
    float currentHeight = 1.0;
    
    for(int i=0; i<linearSteps; i++)
    {
        currentHeight = _LNSurface_Front_GBuffer3.SampleLevel(painter_linear_clamp_sampler, currentUV, 0).r;
        
        if(currentLayerDepth >= (1.0 - currentHeight)) // Hit!
        {
            // 2. Binary Search (Refinement)
            // Refine between prevUV and currentUV
            float2 startUV = prevUV;
            float2 endUV = currentUV;
            float startDepth = prevLayerDepth;
            float endDepth = currentLayerDepth;
            
            for(int j=0; j<5; j++) // 5 iterations of binary search
            {
                float2 midUV = (startUV + endUV) * 0.5;
                float midDepth = (startDepth + endDepth) * 0.5;
                float midHeight = _LNSurface_Front_GBuffer3.SampleLevel(painter_linear_clamp_sampler, midUV, 0).r;
                
                if(midDepth >= (1.0 - midHeight))
                {
                    endUV = midUV;
                    endDepth = midDepth;
                }
                else
                {
                    startUV = midUV;
                    startDepth = midDepth;
                }
            }
            outLayerDepth = (startDepth + endDepth) * 0.5;
            return (startUV + endUV) * 0.5;
        }
        
        prevUV = currentUV;
        prevLayerDepth = currentLayerDepth;
        prevHeight = currentHeight;
        
        currentUV -= deltaUV;
        currentLayerDepth += stepSize;
    }
    
    outLayerDepth = currentLayerDepth;
    return currentUV;
}


[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // 화면 범위를 벗어나는 스레드 제외
    if (id.x >= (uint)_LNSurface_ScreenParams.x || id.y >= (uint)_LNSurface_ScreenParams.y)
        return;

    // 1. GBuffer 파라미터 읽기
    float4 gbuffer1 = _LNSurface_Front_Packed[id.xy];
    float mask = gbuffer1.a;
    
    // 마스크 체크 (오브젝트가 없는 허공 처리 안 함)
    if (mask <= 0.001)
    {
        _Result[id.xy] = _SceneColor[id.xy]; 
        return;
    }

    float linearDepth = gbuffer1.b;
    
    float4 gbuffer0 = _LNSurface_Front_Color[id.xy];
    float4 gbuffer2 = _LNSurface_Front_GBuffer2[id.xy];
    float4 gbuffer3 = _LNSurface_Front_GBuffer3[id.xy];
    
    float3 albedo = gbuffer0.rgb;
    float metallic = gbuffer2.r;
    float smoothness = gbuffer2.g;
    
    // Extra2에서 데이터 읽기
    float shadow = gbuffer2.b;
    
    // G채널 언패킹 (Subsurface, Anisotropic)
    float packedG = gbuffer2.a * 255.0;
    float subsurface = floor(packedG / 16.0) / 15.0;
    float anisotropic = (packedG - floor(packedG / 16.0) * 16.0) / 15.0;
    
    // B채널 언패킹 (SSS Intensity, SSS Thickness)
    float packedB = gbuffer3.a * 255.0;
    float sssIntensity = floor(packedB / 16.0) / 15.0 * 10.0; // 0~10 범위로 복원
    float sssThickness = (packedB - floor(packedB / 16.0) * 16.0) / 15.0 * 100.0; // 0~100 범위로 복원
    
    // Specular Strength, DiffuseWrap 등은 현재 Extra 텍스처에서 제거됨 (필요 시 복구 또는 상수 처리)
    float specularStrength = _SpecularStrength; // Global Setting
    float diffuseWrap = _DiffuseWrap; // Global Setting
    
    // Normal 복원
    float3 normalWS = DecodeNormal(gbuffer1.rg);
    
    // 2. 월드 공간 좌표 재구성
    float2 uv = (float2(id.xy) + 0.5) / _LNSurface_ScreenParams;
    
    float3 viewPos = GetViewSpacePos(uv, linearDepth);
    float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
    
    // 카메라 위치 추출 및 시선 방향 계산
    float3 cameraPosWS = float3(_CameraToWorldMatrix._m03, _CameraToWorldMatrix._m13, _CameraToWorldMatrix._m23);
    float3 viewDir = normalize(cameraPosWS - worldPos);

    // --- Inner POM Logic ---
    float3 innerNormalWS = normalWS; // Default to surface normal
    float3 innerAlbedo = albedo;
    float innerDepth = 0.0;
    
    // Unpack Inner Params from GBuffer4
    float4 innerParamsPacked = _LNSurface_Front_GBuffer4[id.xy];
    
    // Unpack Color (R: 332)
    uint pColor = (uint)(innerParamsPacked.r * 255.0 + 0.5);
    float3 innerColor;
    innerColor.r = float((pColor >> 5) & 7) / 7.0;
    innerColor.g = float((pColor >> 2) & 7) / 7.0;
    innerColor.b = float(pColor & 3) / 3.0;
    
    // Unpack Thickness & IOR (G: 44)
    uint pThickIOR = (uint)(innerParamsPacked.g * 255.0 + 0.5);
    float innerSurfaceThickness = float((pThickIOR >> 4) & 15) / 15.0 * 0.2; // 0.0 ~ 0.2
    float innerIOR = float(pThickIOR & 15) / 15.0 * 2.0 + 1.0; // 1.0 ~ 3.0
    
    // Unpack Blend & Fade (B: 44)
    uint pBlendFade = (uint)(innerParamsPacked.b * 255.0 + 0.5);
    float innerBlend = float((pBlendFade >> 4) & 15) / 15.0; // 0.0 ~ 1.0
    
    // Apply square curve for innerDepthFade for smoother tuning
    float rawFade = float(pBlendFade & 15) / 15.0;
    float innerDepthFade = (rawFade * rawFade) * 5.0; // 0.0 ~ 5.0
    
    // Unpack Absorption & Turbidity (A: 44)
    // Apply cubic curve (x^3) to provide extremely fine precision near 0
    uint pAbsTurb = (uint)(innerParamsPacked.a * 255.0 + 0.5);
    float rawAbs = float((pAbsTurb >> 4) & 15) / 15.0;
    float rawTurb = float(pAbsTurb & 15) / 15.0;

    // x^2 gives a good balance between precision near 0 and visible change
    float resinAbsorption = pow(rawAbs, 4.0) * 5.0; // 0.0 ~ 10.0
    float resinTurbidity = pow(rawTurb, 4.0) * 0.75; // 0.0 ~ 1.5

    // Mask Unpacking for Triplanar
    int maskFlags = int(mask * 255.0 + 0.5);
    bool sssEnabled = (maskFlags & 1) != 0;
    bool triplanarEnabled = (maskFlags & 2) != 0;
    
    float3 innerContribution = 0;
    float finalInnerBlend = 0;
    
    if (_EnableInnerPOM > 0.5)
    {
        // 1. Tangent Space Basis Construction (Improved using Depth Derivatives)
        float2 texelSize = 1.0 / _LNSurface_ScreenParams;
        float dX = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv + float2(texelSize.x, 0), 0).b;
        float dY = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv + float2(0, texelSize.y), 0).b;
        
        float3 posRight = GetViewSpacePos(uv + float2(texelSize.x, 0), dX);
        float3 posUp = GetViewSpacePos(uv + float2(0, texelSize.y), dY);
        
        float3 tangentVS = normalize(posRight - viewPos);
        float3 bitangentVS = normalize(posUp - viewPos);
        
        // Transform to World Space
        float3 tangentWS = mul((float3x3)_CameraToWorldMatrix, tangentVS);
        float3 bitangentWS = mul((float3x3)_CameraToWorldMatrix, bitangentVS);
        
        // Calculate Geometric Normal from reconstructed tangent frame
        float3 geomNormalWS = normalize(cross(tangentWS, bitangentWS));
        
        // Fallback for Geometric Normal (Edge Case Handling)
        // If tangent/bitangent are degenerate or produce NaN, fallback to GBuffer Normal
        if (length(tangentWS) < 0.001 || length(bitangentWS) < 0.001 || any(isnan(geomNormalWS)))
        {
            geomNormalWS = normalWS;
            // Re-orthogonalize tangent basis based on fallback normal
            float3 up = abs(geomNormalWS.y) < 0.999 ? float3(0, 1, 0) : float3(0, 0, 1);
            tangentWS = normalize(cross(up, geomNormalWS));
            bitangentWS = cross(geomNormalWS, tangentWS);
        }

        // Orthonormalize Tangent Basis using Geometric Normal (not Normal Map)
        // This ensures the inner space aligns with the polygon surface
        tangentWS = normalize(tangentWS - geomNormalWS * dot(tangentWS, geomNormalWS));
        bitangentWS = cross(geomNormalWS, tangentWS);
        
        // 2. Refract View Vector (Tangent Space Approximation)
        float3 viewDirTS = float3(
            dot(viewDir, tangentWS),
            dot(viewDir, bitangentWS),
            dot(viewDir, geomNormalWS) // Use Geometric Normal for projection
        );
        
        float3 refractDirTS = viewDirTS;
        refractDirTS.xy /= innerIOR; 
        
        // Normalize XY for UV offset calculation
        float2 viewDirTS_UV = normalize(refractDirTS.xy) * float2(1, -1); 
        
        // Apply Surface Thickness Offset with Aspect Ratio Correction
        float aspect = _LNSurface_ScreenParams.x / _LNSurface_ScreenParams.y;
        float2 thicknessOffset = refractDirTS.xy * innerSurfaceThickness;
        thicknessOffset.y *= aspect; // Correct vertical offset
        
        float2 startUV = uv - thicknessOffset;
        
        // 3. Raymarch (Improved with Binary Search & Jitter)
        float outLayerDepth = 0.0;
        float2 innerUV = CalculateInnerPOM(uv, viewDirTS, innerSurfaceThickness, id.xy, triplanarEnabled, outLayerDepth);
            
        // Calculate physical inner depth (travel distance)
        float nDotV = max(0.001, dot(viewDir, geomNormalWS));
        innerDepth = (outLayerDepth * innerSurfaceThickness) / nDotV;
            
        // Sample Inner Normal (Unpack from 0..1 to -1..1 from GBuffer3 G/B channels)
        float2 packedInner = _LNSurface_Front_GBuffer3.SampleLevel(painter_linear_clamp_sampler, innerUV, 0).gb;
        float3 localInnerNormal = float3(packedInner.x * 2.0 - 1.0, packedInner.y * 2.0 - 1.0, 0);
        localInnerNormal.z = sqrt(max(0, 1.0 - dot(localInnerNormal.xy, localInnerNormal.xy))); // Reconstruct Z
        
        // Transform Local Inner Normal to World Space
        innerNormalWS = normalize(tangentWS * localInnerNormal.x + bitangentWS * localInnerNormal.y + geomNormalWS * localInnerNormal.z);
        
        // Calculate Inner Lighting Contribution
        // We calculate this once here, but it depends on light direction.
        // So we just prepare variables for the loop.
        
        // Fresnel-based Blending
        float NdotV = saturate(abs(dot(normalWS, viewDir)) + 1e-5);
        float fresnel = Local_SchlickFresnel(NdotV);
        finalInnerBlend = innerBlend * (1.0 - fresnel);
    }

    float3 totalDiffuse = 0;
    float3 totalSpecular = 0;
    float3 totalSSS = 0;
    
    // SSCS 적용 (Contact Shadow) - _LNSurface_AO_SSCS_Blurred 의 G 채널
    if (_EnableSSCS > 0.5)
    {
        float sscs = _LNSurface_AO_SSCS_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).g;
        shadow = min(shadow, sscs);
    }

    // 3. 조명 루프 (메인 라이트 + 추가 라이트)
    uint lightLoopCount = (uint)(_AdditionalLightCount + 1);
    for (uint i = 0; i < lightLoopCount; ++i)
    {
        float3 lightColor;
        float3 lightDir;
        float atten = 1.0;

        if (i == 0) // 메인 라이트 처리
        {
            lightDir = normalize(_MainLightDirection.xyz);
            lightColor = _MainLightColor.rgb;
            atten = shadow; // 그림자 데이터 적용
        }
        else // 추가 점광원/스포트 라이트 처리
        {
            uint lightIdx = i - 1;
            float3 lightPos = _AdditionalLightPositions[lightIdx].xyz;
            float3 lightToPos = lightPos - worldPos;
            float distToLight = length(lightToPos); // 거리 계산
            lightDir = normalize(lightToPos);
            atten = GetDistanceAttenuation(lightToPos, _AdditionalLightAttenuations[lightIdx]);
            lightColor = _AdditionalLightColors[lightIdx].rgb;
            
            // SSCS 적용 (추가 라이트)
            if (_EnableSSCS > 0.5)
            {
                float3 lightDirVS = mul((float3x3)_WorldToCameraMatrix, lightDir);
                // 광원까지의 거리와 설정된 최대 거리 중 작은 값을 사용
                float rayDist = min(_SSCS_Distance, distToLight);
                float sscs = RaymarchShadow(viewPos, lightDirVS, rayDist, id.xy);
                atten *= sscs;
            }
        }

        // Diffuse Wrap (확산광이 반대편까지 부드럽게 감싸는 효과)
        float rawNdotL = dot(normalWS, lightDir);
        float NdotL = saturate((rawNdotL + diffuseWrap) / (1.0 + diffuseWrap));
        
        // --- Stylized Shadow Tint 적용 ---
        float3 shadowTintCol = GetShadowColor(lightColor);
        
        // 그림자 강도 (NdotL과 Attenuation을 모두 고려)
        // NdotL이 낮거나(어두운 면) Atten이 낮으면(그림자) 0에 가까워짐
        // diffuseWrap을 고려하여 마스크 생성
        float shadowMask = (rawNdotL + diffuseWrap) / (1.0 + diffuseWrap);
        shadowMask *= atten; // 그림자(Atten)가 있는 곳도 어둡게 처리
        
        // 0~1 범위로 부드럽게 매핑 (ShadowThreshold 적용)
        // _ShadowThreshold가 0.5일 때 기본 범위 (0.0 ~ 0.5)
        // _ShadowThreshold가 1.0일 때 주광 최대 범위 (-0.5 ~ 0.0)
        // _ShadowThreshold가 0.0일 때 그림자 최대 범위 (0.5 ~ 1.0)
        float minThreshold = 0.5 - _ShadowThreshold;
        float maxThreshold = 1.0 - _ShadowThreshold;
        float tintFactor = smoothstep(minThreshold, maxThreshold, shadowMask);
        
        // 밝은 부분은 원래 빛 색상, 어두운 부분은 틴트 색상으로 보간
        float3 litColor = lightColor * atten;
        float3 shadowColor = shadowTintCol * _ShadowTintIntensity;
        
        // 단순 RGB Lerp로 복구
        float3 mixedLightColor = lerp(shadowColor, litColor, tintFactor);

        if (_LightingModel == 0) // Half Lambert (카툰/회화적 연출)
        {
            // Half Lambert는 이미 NdotL을 변형하므로, 여기서는 Tint된 LightColor를 사용
            float halfLambert = rawNdotL * 0.5 + 0.5;
            totalDiffuse += albedo * halfLambert * mixedLightColor;
        }
        else // Disney BRDF (물리 기반 셰이딩)
        {
            float roughness = 1.0 - smoothness;
            roughness = max(roughness * roughness, 0.001);
            float alpha = roughness; 
            
            float3 halfDir = normalize(lightDir + viewDir);
            float NdotV = saturate(abs(dot(normalWS, viewDir)) + 1e-5);
            float NdotH = saturate(dot(normalWS, halfDir));
            float LdotH = saturate(dot(lightDir, halfDir));
            
            // Disney Diffuse & Subsurface Diffuse (모델 내 근사)
            float FD90 = 0.5 + 2.0 * smoothness * LdotH * LdotH;
            float lightScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotL);
            float viewScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotV);
            float baseDiffuse = lightScatter * viewScatter;

            float FSS90 = LdotH * LdotH * smoothness;
            float FSS = (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotL)) * 
                        (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotV));
            float ssDiffuse = 1.25 * (FSS * (1.0 / (NdotL + NdotV + 0.0001) - 0.5) + 0.5);

            float finalDiffuseFactor = lerp(baseDiffuse, ssDiffuse, subsurface);
            
            // Diffuse Term에 mixedLightColor 적용 (NdotL은 mixedLightColor의 그라데이션에 이미 반영됨)
            // 하지만 물리 기반 느낌을 살리기 위해 NdotL을 한번 더 곱해주는 것이 자연스러울 수 있음
            // 여기서는 Stylized 느낌을 위해 NdotL을 직접 곱하지 않고 mixedLightColor에 의존
            float3 diffuseTerm = albedo * finalDiffuseFactor * mixedLightColor; 
            
            // Inner POM Diffuse Contribution
            if (_EnableInnerPOM > 0.5)
            {
                // Inner Normal을 사용한 추가 Diffuse 계산
                float innerNdotL = saturate(dot(innerNormalWS, lightDir));
                // Inner Diffuse는 좀 더 부드럽게 (Wrap)
                innerNdotL = (innerNdotL + 0.5) / 1.5; 
                
                // --- Resin Volumetric Effect (Beer-Lambert & Scattering) ---
                // Transmission: Absorption by Resin (BaseColor)
                // If albedo is (1,1,1), it shouldn't absorb. But to make it more "visible" as resin,
                // we can add a slight darkening factor based on absorption even for white.
                float3 absColor = max(albedo, 0.01);
                float distanceFactor = max(0.0, innerDepth * resinAbsorption * 2.0);
                
                // Physical Beer-Lambert approximation
                float3 transmission = exp(- (1.0 - absColor) * distanceFactor);
                // Also apply base tint independently to ensure behavior at 0 distance
                transmission *= absColor;
                
                // Depth fade override
                float depthFade = exp(-innerDepth * innerDepthFade);
                transmission *= depthFade;
                
                // Turbidity (Scattering Fog)
                float fogAmount = 1.0 - exp(-resinTurbidity * innerDepth * 15.0);
                
                // Fake scattering based on resin color and surface lighting (NOT inner lighting)
                float rawNdotL = dot(normalWS, lightDir);
                float surfaceNdotL = saturate((rawNdotL + diffuseWrap) / (1.0 + diffuseWrap));
                float3 fogColor = albedo * mixedLightColor * surfaceNdotL; 
                
                // Base inner surface diffuse
                float3 innerDiffuse = innerColor * innerNdotL * mixedLightColor;
                
                // Visible inner POM is tinted by the resin transmission
                float3 visibleInner = innerDiffuse * transmission;
                
                // Combine: visible inner is obscured by turbidity fog
                float3 combinedInner = lerp(visibleInner, fogColor, fogAmount);
                
                // Blend Inner Diffuse into surface
                diffuseTerm = lerp(diffuseTerm, combinedInner, finalInnerBlend);
            }
            
            totalDiffuse += diffuseTerm * (1.0 - metallic);
            
            // Specular (GTR2/GGX 기반) - 스펙큘러는 광원 색상을 그대로 따라야 함 (Tint 제외)
            float D = Local_GTR2(NdotH, alpha);
            float3 F0 = lerp(0.08 * specularStrength * float3(1,1,1), albedo, metallic);
            float FH = Local_SchlickFresnel(LdotH);
            float3 F = lerp(F0, float3(1,1,1), FH);
            float G = Local_G_Smith(NdotV, NdotL, 0.25);
            
            float3 specTerm = (D * F * G) / (4.0 * NdotL * NdotV + 0.0001);
            
            // Inner POM Specular Contribution (Coat Layer 느낌)
            if (_EnableInnerPOM > 0.5)
            {
                // Inner Normal을 사용한 추가 Specular
                float innerNdotH = saturate(dot(innerNormalWS, halfDir));
                float innerD = Local_GTR2(innerNdotH, alpha * 0.8); // Inner is slightly sharper
                float3 innerSpec = (innerD * F * G) / (4.0 * NdotL * NdotV + 0.0001);
                
                // Resin Volumetric Effect for Specular
                float3 absColor = max(albedo, 0.01);
                float distanceFactor = max(0.0, innerDepth * resinAbsorption * 2.0);
                
                float3 transmissionSpec = exp(- (1.0 - absColor) * distanceFactor) * absColor;
                transmissionSpec *= exp(-innerDepth * innerDepthFade);
                
                float fogAmount = 1.0 - exp(-resinTurbidity * innerDepth * 15.0);
                
                // Additive Blending for "Sparkle" inside
                specTerm += innerSpec * transmissionSpec * (1.0 - fogAmount) * finalInnerBlend; 
            }
            
            totalSpecular += max(0, specTerm) * lightColor * NdotL * PI * atten;
        }

        // 4. 투과형 하부표면 산란 (Translucency SSS)
        if (_EnableSSS > 0.5)
        {
            float frontDepth = linearDepth;
            float backDepth = _LNSurface_Back_Packed[id.xy].b;
            
            // Back Depth 유효성 검사 (빈 공간 또는 오류 처리)
            if (backDepth > 900.0 || backDepth < 0.001 || backDepth <= frontDepth)
            {
                backDepth = 10000.0; // 무한대 두께로 취급
            }
            
            float thickness = max(0, backDepth - frontDepth) * sssThickness;
            
            // 라이트가 뒤에서 비칠 때의 산란 강도 계산
            float backLightFactor = saturate((-rawNdotL + 0.2) * 2.0); 
            
            // SSS Intensity를 밝기 Multiplier로 사용
            float attenuation = exp(-thickness);
            
            // SSSS 감쇠 (Inner POM이 덮어씀)
            float sssAttenuation = 1.0;
            if (_EnableInnerPOM > 0.5)
            {
                sssAttenuation = (1.0 - finalInnerBlend * 0.8);
            }
            
            totalSSS += attenuation * albedo.rgb * lightColor * backLightFactor * atten * sssIntensity * sssAttenuation;
            
            // Inner POM에 SSS 느낌 추가 (Back Light가 있을 때 내부가 밝아짐)
            if (_EnableInnerPOM > 0.5)
            {
                float3 innerScattering = lightColor * atten * sssIntensity * backLightFactor * 0.5;
                // Use albedo instead of innerColor because light scatters through the resin volume
                totalDiffuse += innerScattering * albedo * finalInnerBlend;
            }
        }
    }

    // 주변광 (Ambient / SH) 계산
    float3 ambientColor = SampleSH(normalWS) * albedo * (1.0 - metallic);

    // --- SSGI 적용 (간접광) ---
    float3 ssgi = 0;
    if (_EnableSSGI > 0.5)
    {
        // Nearest-Depth Upsampling
        float width, height;
        _LNSurface_SSGI_Blurred.GetDimensions(width, height);
        float2 ssgiTexelSize = float2(1.0 / width, 1.0 / height);

        // 현재 픽셀의 저해상도 텍스처 상의 좌표 (0.5 씩 오프셋되어 텍셀 중심을 맞춤)
        float2 lowResUV = uv * float2(width, height) - 0.5;
        float2 baseUV = floor(lowResUV);

        // 4개의 샘플 UV (저해상도 텍스처 기준)
        float2 uv00 = (baseUV + float2(0.5, 0.5)) * ssgiTexelSize;
        float2 uv10 = (baseUV + float2(1.5, 0.5)) * ssgiTexelSize;
        float2 uv01 = (baseUV + float2(0.5, 1.5)) * ssgiTexelSize;
        float2 uv11 = (baseUV + float2(1.5, 1.5)) * ssgiTexelSize;

        // 각 샘플의 깊이와 색상 가져오기
        // 주의: Depth는 Full-Res 텍스처이지만, 저해상도 그리드 위치에 맞춰 샘플링하여 '저해상도 픽셀이 가졌던 깊이'를 근사함
        float d00 = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv00, 0).b;
        float d10 = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv10, 0).b;
        float d01 = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv01, 0).b;
        float d11 = _LNSurface_Front_Packed.SampleLevel(painter_point_clamp_sampler, uv11, 0).b;

        float3 c00 = _LNSurface_SSGI_Blurred.SampleLevel(painter_point_clamp_sampler, uv00, 0).rgb;
        float3 c10 = _LNSurface_SSGI_Blurred.SampleLevel(painter_point_clamp_sampler, uv10, 0).rgb;
        float3 c01 = _LNSurface_SSGI_Blurred.SampleLevel(painter_point_clamp_sampler, uv01, 0).rgb;
        float3 c11 = _LNSurface_SSGI_Blurred.SampleLevel(painter_point_clamp_sampler, uv11, 0).rgb;

        // 현재 픽셀 깊이와의 차이 계산
        float w00 = abs(d00 - linearDepth);
        float w10 = abs(d10 - linearDepth);
        float w01 = abs(d01 - linearDepth);
        float w11 = abs(d11 - linearDepth);

        // 가장 깊이 차이가 적은 샘플 선택 (Nearest Depth)
        float minDiff = w00;
        ssgi = c00;

        if (w10 < minDiff) { minDiff = w10; ssgi = c10; }
        if (w01 < minDiff) { minDiff = w01; ssgi = c01; }
        if (w11 < minDiff) { minDiff = w11; ssgi = c11; }

        ambientColor += ssgi * albedo * _SSGI_Intensity * (1.0 - metallic);
    }

    // --- SSAO 적용 (볼륨 차폐광) --- - _LNSurface_AO_SSCS_Blurred 의 R 채널
    float ao = 1.0;
    if (_EnableSSAO > 0.5)
    {
        // Half-Res AO+SSCS 텍스처를 Full-Res UV로 샘플링 (Linear Interpolation)
        float rawAO = _LNSurface_AO_SSCS_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).r;
        ao = saturate(1.0 - rawAO * _SSAO_Intensity);
    }
    ambientColor *= ao;

    // --- 화면 공간 반사 (SSR) 적용 ---
    float3 reflectionColor = 0;
    if (_EnableSSR > 0.5 && smoothness > 0.01)
    {
        // Half-Res SSR 텍스처를 Full-Res UV로 샘플링 (Linear Interpolation)
        reflectionColor = _LNSurface_SSR_Blurred.SampleLevel(painter_linear_clamp_sampler, uv, 0).rgb;
    }
    
    // 프레넬 법칙에 따른 환경광 및 반사광 합성
    float3 specColor = lerp(float3(0.04, 0.04, 0.04), albedo.rgb, metallic);
    float3 F = specColor + (1.0 - specColor) * Local_SchlickFresnel(max(dot(normalWS, viewDir), 0.0));
    
    // Roughness에 따른 반사광 블렌딩 (거칠수록 반사광이 약해짐)
    float roughness = saturate(1.0 - smoothness);
    
    // SSR Fade: Smoothness가 낮을수록(거칠수록) 반사를 부드럽게 끔
    float ssrFade = smoothstep(0.05, 0.2, smoothness);
    
    // Reflection Strength: 거칠수록 반사 강도 감소 (제곱 감쇠)
    float reflectionStrength = (1.0 - roughness);
    reflectionStrength *= reflectionStrength; 
    
    ambientColor += reflectionColor * F * reflectionStrength * ssrFade;

    // 최종 픽셀 컬러 출력 (확산광 + 주변광/반사광 + 스펙큘러 + SSS)
    float3 finalResult = totalDiffuse + ambientColor + totalSpecular + totalSSS;

    // 7. 디버그 모드 시각화 (A채널 데이터 확인 등 추가)
    if (_DebugMode > 0)
    {
        if (_DebugMode == 1) _Result[id.xy] = float4(gbuffer1.rgb, 1.0); // GBuffer1
        else if (_DebugMode == 2) _Result[id.xy] = float4(albedo, 1.0); // Albedo
        else if (_DebugMode == 3) _Result[id.xy] = float4(innerNormalWS * 0.5 + 0.5, 1.0); // Final Normal
        else if (_DebugMode == 4) _Result[id.xy] = float4(metallic.xxx, 1.0); // Metallic
        else if (_DebugMode == 5) _Result[id.xy] = float4(smoothness.xxx, 1.0); // Smoothness
        else if (_DebugMode == 6) _Result[id.xy] = float4(subsurface.xxx, 1.0); // Subsurface
        else if (_DebugMode == 7) _Result[id.xy] = float4(anisotropic.xxx, 1.0); // Aniso
        else if (_DebugMode == 8) _Result[id.xy] = float4((sssIntensity / 10.0).xxx, 1.0); // SSS Int
        else if (_DebugMode == 9) _Result[id.xy] = float4(shadow.xxx, 1.0); // Shadow
        else if (_DebugMode == 10) _Result[id.xy] = float4(innerColor, 1.0); // Inner Color
        else if (_DebugMode == 11) _Result[id.xy] = float4((innerSurfaceThickness / 0.2).xxx, 1.0); // Inner Thick
        else if (_DebugMode == 12) _Result[id.xy] = float4(innerBlend.xxx, 1.0); // Inner Blend
        else if (_DebugMode == 13) _Result[id.xy] = float4(mask.xxx, 1.0); // Mask (GBuffer1 A)
        else if (_DebugMode == 14) _Result[id.xy] = float4((innerDepth / 0.5).xxx, 1.0); // Inner Depth
        else if (_DebugMode == 15) _Result[id.xy] = float4((resinAbsorption / 10.0).xxx, 1.0); // Resin Absorption
        else if (_DebugMode == 16) _Result[id.xy] = float4(resinTurbidity.xxx, 1.0); // Resin Turbidity
        _Result[id.xy] = float4(finalResult, 1.0); // Fallback if no debug mode matches
        return;
    }

    _Result[id.xy] = float4(finalResult, 1.0);
}
