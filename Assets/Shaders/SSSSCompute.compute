#pragma kernel CSMain

RWTexture2D<float4> _Result;

Texture2D<float4> _SSSS_Front_Color; 
Texture2D<float4> _SSSS_Front_Normal;
Texture2D<float4> _SSSS_Front_Depth;

Texture2D<float4> _SSSS_Back_Depth;
Texture2D<float4> _SSSS_Scene_Color; 
Texture2D<float4> _SSSS_Mask; 

SamplerState sampler_LinearClamp;

float _SSS_Intensity;
float _SSS_ThicknessScale;
float2 _ScreenParams;
float4 _MainLightDirection; 

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ScreenParams.x || id.y >= _ScreenParams.y)
        return;

    float2 uv = id.xy / _ScreenParams;
    
    float4 frontColor = _SSSS_Front_Color[id.xy];
    float sssMask = _SSSS_Mask[id.xy].r; 
    
    float4 sceneColor = _SSSS_Scene_Color[id.xy];
    
    if (sssMask > 0.001)
    {
        float frontDepth = _SSSS_Front_Depth[id.xy].r;
        float backDepth = _SSSS_Back_Depth[id.xy].r;
        
        // 노멀 언팩 (0..1 -> -1..1)
        float3 normal = _SSSS_Front_Normal[id.xy].rgb * 2.0 - 1.0;
        
        // 두께 계산
        float thickness = max(0, backDepth - frontDepth) * _SSS_ThicknessScale;
        
        // 역광(Backlighting) 계수
        // 광원이 표면의 "뒤쪽"에 얼마나 있는지를 계산합니다.
        // NdotL < 0 은 빛이 표면의 뒷면을 비추고 있음을 의미합니다.
        float NdotL = dot(normal, _MainLightDirection.xyz);
        float backLightStart = 0.0; // 스치듯 지나가는 각도에서의 빛 번짐을 허용하기 위한 오프셋
        float backLightFactor = saturate((-NdotL + backLightStart) * 1.5); 
        
        // 역광에 따른 SSS 강도 강화
        // 빛이 뒤에 있을 때(backLightFactor ~ 1.0), 효과를 증폭시킵니다.
        float intensity = _SSS_Intensity * (1.0 + backLightFactor * 2.0);

        // SSS 효과: 물체를 통과하는 빛
        // 얇은 영역일수록 더 밝습니다. SSS 컬러로 앞면 텍스처(base color)를 사용합니다.
        float3 sssEffect = exp(-thickness * intensity) * frontColor.rgb;
        
        // 합성: 씬 컬러(디퓨즈 + 그림자) + SSS 효과
        // SSS 효과를 기존 씬 컬러에 더합니다(Add).
        // 이렇게 하면 오브젝트 위의 그림자는 유지되면서, 얇은 부분은 SSS 빛으로 "채워지는" 효과를 냅니다.
        float3 finalColor = sceneColor.rgb + sssEffect * sssMask;
        
        _Result[id.xy] = float4(finalColor, 1.0);
    }
    else
    {
        _Result[id.xy] = sceneColor;
    }
}
