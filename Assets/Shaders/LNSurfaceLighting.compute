#pragma kernel CSMain

RWTexture2D<float4> _Result;

// Textures
Texture2D<float4> _LNSurface_Front_Color;  // RGB: Albedo, A: Unused
Texture2D<float4> _LNSurface_Front_Normal; // RGB: Normal, A: Unused
Texture2D<float4> _LNSurface_Mask;         // R: Mask
Texture2D<float4> _LNSurface_Front_Depth; // R: Linear Depth
Texture2D<float4> _LNSurface_Back_Depth;  // R: Linear Depth (Back face)
Texture2D<float4> _LNSurface_Front_Extra; // R: Metallic, G: SpecularStrength, B: Packed(Subsurface, Anisotropic), A: Unused
Texture2D<float4> _LNSurface_Front_Extra2; // R: Smoothness, G: Shadow, B: DiffuseWrap, A: Unused
Texture2D<float4> _SceneColor;             // Scene Color (Background)

// Params
float2 _ScreenParams;
float4 _MainLightDirection;
float4 _MainLightColor;
int _AdditionalLightCount;
float4 _AdditionalLightPositions[16];
float4 _AdditionalLightColors[16];
float4 _AdditionalLightAttenuations[16]; // x: 1/range^2, y: 1

float _SSS_Intensity;    // SSS Intensity
float _SSS_ThicknessScale; // SSS Thickness Scale
float _EnableSSS;          // Toggle SSS

// SH Params
float4 unity_SHAr;
float4 unity_SHAg;
float4 unity_SHAb;
float4 unity_SHBr;
float4 unity_SHBg;
float4 unity_SHBb;
float4 unity_SHC;

// Matrix Params
float4x4 _InverseViewProjectionMatrix; 
float4x4 _InverseProjectionMatrix;
float4x4 _CameraToWorldMatrix;
int _LightingModel; // 0: HalfLambert, 1: DisneyBRDF

#ifndef PI
#define PI 3.14159265359f
#endif

// --- Local Disney BRDF Functions (Safe Naming) ---
float Local_Sqr(float x) { return x * x; }

float Local_SchlickFresnel(float u)
{
    float m = clamp(1.0 - u, 0.0, 1.0);
    float m2 = m * m;
    return m2 * m2 * m; // pow(m, 5)
}

float Local_GTR2(float NdotH, float a)
{
    float a2 = a * a;
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

float Local_G_Smith(float NdotV, float NdotL, float alpha)
{
    float a = Local_Sqr(alpha);
    float k = Local_Sqr(alpha + 1.0) * 0.125; // Direct Light
    float g1 = NdotV / (NdotV * (1.0 - k) + k);
    float g2 = NdotL / (NdotL * (1.0 - k) + k);
    return g1 * g2;
}

// Distance Attenuation
float GetDistanceAttenuation(float3 lightDir, float4 attenuation)
{
    float d2 = dot(lightDir, lightDir);
    float rangeCheck = saturate(1.0 - d2 * attenuation.x);
    return rangeCheck * rangeCheck / (d2 + 0.01);
}

// SH Evaluation Function (Matches Unity's ShadeSH9)
float3 SampleSH(float3 normal)
{
    float4 n = float4(normal, 1.0);
    float3 x1, x2, x3;
    
    // Linear + Constant
    x1.r = dot(unity_SHAr, n);
    x1.g = dot(unity_SHAg, n);
    x1.b = dot(unity_SHAb, n);
    
    // Quadratic polynomials
    float4 vB = n.xyzz * n.yzzx;
    x2.r = dot(unity_SHBr, vB);
    x2.g = dot(unity_SHBg, vB);
    x2.b = dot(unity_SHBb, vB);
    
    // Final Quadratic term
    float vC = n.x * n.x - n.y * n.y;
    x3 = unity_SHC.rgb * vC;
    
    return max(0, x1 + x2 + x3);
}
// ------------------------------------------------

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ScreenParams.x || id.y >= _ScreenParams.y)
        return;

    // Mask Check
    float mask = _LNSurface_Mask[id.xy].r;
    if (mask <= 0.001)
    {
        // Output Scene Color (Background)
        _Result[id.xy] = _SceneColor[id.xy]; 
        return;
    }

    // 1. Read Data
    float4 gbuffer0 = _LNSurface_Front_Color[id.xy];
    float4 gbuffer1 = _LNSurface_Front_Normal[id.xy];
    float4 gbufferExtra = _LNSurface_Front_Extra[id.xy];
    float4 gbufferExtra2 = _LNSurface_Front_Extra2[id.xy];
    
    // Unpack Data
    float3 albedo = gbuffer0.rgb;
    float metallic = gbufferExtra.r;
    float specularStrength = gbufferExtra.g;
    float smoothness = gbufferExtra2.r;
    float shadow = gbufferExtra2.g; 
    float diffuseWrap = gbufferExtra2.b;
    
    // Unpack B Channel (Subsurface 4bit + Anisotropic 4bit)
    float packedB = gbufferExtra.b * 255.0;
    float subsurface = floor(packedB / 16.0) / 15.0;
    float anisotropic = (packedB - floor(packedB / 16.0) * 16.0) / 15.0;
    
    // Normal Unpack
    float3 normalWS = normalize(gbuffer1.rgb * 2.0 - 1.0);
    
    // 2. Reconstruct World Position
    float2 uv = (float2(id.xy) + 0.5) / _ScreenParams;
    float linearDepth = _LNSurface_Front_Depth[id.xy].r;
    
    float fovScaleX = _InverseProjectionMatrix._m00;
    float fovScaleY = _InverseProjectionMatrix._m11;
    
    float4 clipPos;
    clipPos.xy = uv * 2.0 - 1.0;
    clipPos.z = 0; 
    clipPos.w = 1;

    float3 viewPos;
    viewPos.z = -linearDepth; 
    viewPos.x = clipPos.x * fovScaleX * -viewPos.z; 
    viewPos.y = clipPos.y * fovScaleY * -viewPos.z;
    
    float3 worldPos = mul(_CameraToWorldMatrix, float4(viewPos, 1.0)).xyz;
    float3 cameraPosWS = float3(_CameraToWorldMatrix._m03, _CameraToWorldMatrix._m13, _CameraToWorldMatrix._m23);
    float3 viewDir = normalize(cameraPosWS - worldPos);

    float3 totalDiffuse = float3(0, 0, 0);
    float3 totalSpecular = float3(0, 0, 0);
    float3 totalSSS = float3(0, 0, 0);

    // 3. Lighting Loop (Main Light + Additional Lights)
    uint lightLoopCount = (uint)(_AdditionalLightCount + 1);
    for (uint i = 0; i < lightLoopCount; ++i)
    {
        float3 lightColor;
        float3 lightDir;
        float atten = 1.0;

        if (i == 0) // Main Light
        {
            lightDir = normalize(_MainLightDirection.xyz);
            lightColor = _MainLightColor.rgb;
            atten = shadow;
        }
        else // Additional Light
        {
            uint lightIdx = i - 1;
            float3 lightPos = _AdditionalLightPositions[lightIdx].xyz;
            float3 lightToPos = lightPos - worldPos;
            float distSq = dot(lightToPos, lightToPos);
            lightDir = normalize(lightToPos);
            
            atten = GetDistanceAttenuation(lightToPos, _AdditionalLightAttenuations[lightIdx]);
            lightColor = _AdditionalLightColors[lightIdx].rgb;
        }

        // Apply Diffuse Wrap
        float rawNdotL = dot(normalWS, lightDir);
        float NdotL = saturate((rawNdotL + diffuseWrap) / (1.0 + diffuseWrap));

        if (_LightingModel == 0) // Half Lambert
        {
            float halfLambert = rawNdotL * (1.0 - diffuseWrap) + diffuseWrap;
            totalDiffuse += albedo * halfLambert * lightColor * atten;
        }
        else // Disney BRDF
        {
            float roughness = 1.0 - smoothness;
            roughness = max(roughness * roughness, 0.001);
            float alpha = roughness; 
            
            float3 halfDir = normalize(lightDir + viewDir);
            float NdotV = saturate(abs(dot(normalWS, viewDir)) + 1e-5);
            float NdotH = saturate(dot(normalWS, halfDir));
            float LdotH = saturate(dot(lightDir, halfDir));
            
            // Diffuse (Disney)
            float FD90 = 0.5 + 2.0 * smoothness * LdotH * LdotH;
            float lightScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotL);
            float viewScatter = 1.0 + (FD90 - 1.0) * Local_SchlickFresnel(NdotV);
            float baseDiffuse = lightScatter * viewScatter;

            // Subsurface Diffuse
            float FSS90 = LdotH * LdotH * smoothness;
            float FSS = (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotL)) * 
                        (1.0 + (FSS90 - 1.0) * Local_SchlickFresnel(NdotV));
            float ssDiffuse = 1.25 * (FSS * (1.0 / (NdotL + NdotV + 0.0001) - 0.5) + 0.5);

            float finalDiffuseFactor = lerp(baseDiffuse, ssDiffuse, subsurface);
            float3 diffuseTerm = albedo * finalDiffuseFactor * NdotL * lightColor * atten;
            totalDiffuse += diffuseTerm * (1.0 - metallic);
            
            // Specular
            float D = Local_GTR2(NdotH, alpha);
            float3 F0 = lerp(0.08 * specularStrength * float3(1,1,1), albedo, metallic);
            float FH = Local_SchlickFresnel(LdotH);
            float3 F = lerp(F0, float3(1,1,1), FH);
            float G = Local_G_Smith(NdotV, NdotL, 0.25);
            
            float3 specTerm = (D * F * G) / (4.0 * NdotL * NdotV + 0.0001);
            totalSpecular += max(0, specTerm) * lightColor * NdotL * PI * atten;
        }

        // 4. SSS
        if (_EnableSSS > 0.5)
        {
            float frontDepth = _LNSurface_Front_Depth[id.xy].r;
            float backDepth = _LNSurface_Back_Depth[id.xy].r;
            float thickness = max(0, backDepth - frontDepth) * _SSS_ThicknessScale;
            
            float backLightFactor = saturate((-rawNdotL + 0.2) * 2.0); 
            float sssIntensity = _SSS_Intensity * (1.0 + backLightFactor);
            totalSSS += exp(-thickness * sssIntensity) * albedo.rgb * lightColor * backLightFactor * atten;
        }
    }

    // Ambient (SH) - Calculated once
    float3 ambientColor = SampleSH(normalWS) * albedo * (1.0 - metallic);

    // Final Output
    _Result[id.xy] = float4(totalDiffuse + ambientColor + totalSpecular + totalSSS, 1.0);
}
